{"hierarchy":{"paths":[["doc:\/\/com.karwa.WebURL\/documentation\/WebURL"]]},"kind":"article","abstract":[{"text":"Best practices when mixing URL standards","type":"text"}],"schemaVersion":{"minor":3,"major":0,"patch":0},"primaryContentSections":[{"content":[{"level":2,"text":"Introduction","type":"heading","anchor":"Introduction"},{"inlineContent":[{"type":"text","text":"The WebURL package comes with a number of APIs to support using "},{"code":"WebURL","type":"codeVoice"},{"type":"text","text":" values with Foundation:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Conversion initializers."}],"type":"paragraph"},{"inlineContent":[{"text":"Convert values between ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":" simply by constructing the type you need.","type":"text"},{"text":" ","type":"text"},{"text":"These initializers verify that both types have an equivalent interpretation of the URL value.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let sourceURL = WebURL(\"https:\/\/api.example.com\/foo\/bar?baz\")!","","\/\/ WebURL -> Foundation.URL","let nsURL = URL(sourceURL)  \/\/ ✅ \"https:\/\/api.example.com\/foo\/bar?baz\"    ","\/\/ Foundation.URL -> WebURL","let webURL = WebURL(nsURL)  \/\/ ✅ \"https:\/\/api.example.com\/foo\/bar?baz\""],"type":"codeListing"}]},{"content":[{"inlineContent":[{"text":"Convenience wrappers.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Make requests using "},{"type":"codeVoice","code":"URLSession"},{"type":"text","text":" directly from a "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" value, eliminating the conversion boilerplate."}],"type":"paragraph"},{"code":["\/\/ 😌 Make a URLSession request using a WebURL.","let webURL = WebURL(\"https:\/\/api.example.com\/foo\/bar?baz\")!","let dataTask = URLSession.shared.dataTask(with: webURL) { data, response, error in","  \/\/ ...","}","dataTask.resume()"],"type":"codeListing","syntax":"swift"}]}],"type":"orderedList"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"For these APIs to be available, you must import the "},{"type":"codeVoice","code":"WebURLFoundationExtras"},{"type":"text","text":" module:"}]},{"code":["import Foundation","import WebURL","import WebURLFoundationExtras  \/\/ <--"],"syntax":"swift","type":"codeListing"}],"style":"note","type":"aside","name":"Note"},{"inlineContent":[{"type":"text","text":"These APIs enable you to use "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" for more of your URL processing, while still supporting clients"},{"type":"text","text":" "},{"type":"text","text":"or using libraries which require "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"For many applications, this will “just work”. However, there are some subtleties you should","type":"text"},{"text":" ","type":"text"},{"text":"generally be aware of. The issues we will be discussing are, in fact, defects in URLs themselves;","type":"text"},{"text":" ","type":"text"},{"text":"and they happen in every programming language, with every URL library, and can affect the security","type":"text"},{"text":" ","type":"text"},{"text":"and robustness of your code.","type":"text"}],"type":"paragraph"},{"level":2,"text":"URL Strings are Ambiguous","type":"heading","anchor":"URL-Strings-are-Ambiguous"},{"inlineContent":[{"text":"Almost all systems rely on URLs, often for vital communication with both local and remote services,","type":"text"},{"text":" ","type":"text"},{"text":"or processing requests from other devices; and data extracted from URLs is often used to make security-","type":"text"},{"text":" ","type":"text"},{"text":"and privacy-sensitive decisions. It may be surprising, then, to learn that ","type":"text"},{"inlineContent":[{"type":"text","text":"URL strings are ambiguous"}],"type":"strong"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"URL standards have been revised many times over the decades, resulting in incompatibilities."},{"type":"text","text":" "},{"type":"text","text":"It is difficult to ensure that all code which processes a URL string interprets it in exactly the same way and"},{"type":"text","text":" "},{"type":"text","text":"derives the same information from it. That is particularly true of networked clients, each of which might"},{"type":"text","text":" "},{"type":"text","text":"use entirely different languages and libraries to process URLs, but even local applications"},{"type":"text","text":" "},{"type":"text","text":"might expose data to multiple URL parsers, perhaps in dependencies of dependencies."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Moreover, web browsers (typically one of the most important clients) have not been able to conform to "},{"inlineContent":[{"type":"text","text":"any"}],"type":"emphasis"},{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"historical standards because they must maintain compatibility with the web. The result is a surprising amount"},{"type":"text","text":" "},{"type":"text","text":"of variety in how URL strings are actually interpreted, and occasional disagreements;"},{"type":"text","text":" "},{"type":"text","text":"and given how much we rely on URLs, that can lead to unexpected behavior and even exploitable vulnerabilities."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Enter "},{"type":"strong","inlineContent":[{"text":"WebURL","type":"text"}]},{"type":"text","text":". WebURL conforms to the latest industry standard, which formally defines URL parsing"},{"type":"text","text":" "},{"type":"text","text":"in a way that is compatible with the web platform. You should expect "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" to work exactly as your browser does."},{"type":"text","text":" "},{"type":"text","text":"There is even a shared test-suite between "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":", the major browsers, and other library implementations,"},{"type":"text","text":" "},{"type":"text","text":"to help ensure consistency."}],"type":"paragraph"},{"inlineContent":[{"text":"So what kind of disagreements and vulnerabilities are we talking about? Consider the following:","type":"text"}],"type":"paragraph"},{"code":["\/\/ Q: What is the hostname of this URL?","let urlString = \"http:\/\/foo@evil.com:80@example.com\/\" ","","WebURL(urlString)!.hostname  \/\/ \"example.com\"","URL(string: urlString)!.host \/\/ \"evil.com\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Chrome, Safari, Firefox, Go, Python, NodeJS, and Rust all agree with WebURL - that this identifier"},{"type":"text","text":" "},{"type":"text","text":"points to "},{"type":"codeVoice","code":"\"example.com\""},{"type":"text","text":". If you paste it in your browser, that’s where it will go."},{"type":"text","text":" "},{"type":"text","text":"But since Foundation’s interpretation is based on an obsolete standard that is not web-compatible,"},{"type":"text","text":" "},{"type":"text","text":"it would send a request to "},{"type":"codeVoice","code":"\"evil.com\""},{"type":"text","text":" instead."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"These are the sorts of differences we’re talking about - “regular” URLs work like you’d expect, of course"},{"type":"text","text":" "},{"type":"text","text":"(again - WebURL works just like your browser; "},{"inlineContent":[{"text":"adopting WebURL won’t break everything","type":"text"}],"type":"strong"},{"type":"text","text":"), but there are these"},{"type":"text","text":" "},{"type":"text","text":"little details which can and have been exploited by attackers in surprising ways. And as you can see,"},{"type":"text","text":" "},{"type":"text","text":"generally WebURL’s interpretation is the more compatible one, because it matches the web."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using multiple URL standards safely is a difficult problem, but in a sense it’s a problem we already live with."},{"type":"text","text":" "},{"type":"text","text":"We’ve devised a few simple guidelines to help your code deal with this situation more robustly:"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Store and communicate URLs using URL types. Avoid passing them around as strings.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Each URL string should be interpreted by "},{"inlineContent":[{"type":"text","text":"only one"}],"type":"strong"},{"type":"text","text":" parser."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"If you must store or communicate a URL as a string (e.g. in JSON),","type":"text"},{"text":" ","type":"text"},{"text":"document which parser should be used to interpret it.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"If no parser is specified, ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" is a good default.","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The lack of alignment in URL standards is an issue that is being actively exploited, particularly in"},{"type":"text","text":" "},{"type":"text","text":"Server-Side Request Forgery (SSRF) vulnerabilities. In the following sections, we’ll discuss the above advice"},{"type":"text","text":" "},{"type":"text","text":"in more detail, including examples of actual exploits and how these practices could have avoided them."}]}],"style":"important","type":"aside","name":"Important"},{"level":2,"text":"URL Types are Unambiguous","type":"heading","anchor":"URL-Types-are-Unambiguous"},{"inlineContent":[{"type":"text","text":"The first guideline is to prefer storing and communicating URLs using URL types, rather than as strings."},{"type":"text","text":" "},{"type":"text","text":"The meaning of a plain string can be ambiguous, but a value with a type such as "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" or "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" "},{"type":"text","text":"communicates precisely how it should be interpreted, and this enables initializers which verify that semantics"},{"type":"text","text":" "},{"type":"text","text":"are maintained across a conversion."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For example, consider the demonstration URL from the previous section. Both "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" and "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" were able"},{"type":"text","text":" "},{"type":"text","text":"to parse the raw URL string, but saw different components from it. Now, let’s try parsing the string as a"},{"type":"text","text":" "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":", and converting it to a "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["let urlString = \"http:\/\/foo@evil.com:80@example.com\/\" ","","let nsURL = URL(string: urlString)!","print(nsURL.host) \/\/ \"evil.com\"","WebURL(nsURL)     \/\/ ✅ nil - URL is ambiguous"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The initializer checks that both types agree about what the URL means. In this case, they don’t,"},{"type":"text","text":" "},{"type":"text","text":"so the conversion fails. This is a "},{"inlineContent":[{"text":"much better outcome","type":"text"}],"type":"strong"},{"type":"text","text":" than accidentally sending data to the wrong server!"}],"type":"paragraph"},{"inlineContent":[{"text":"Something interesting happens if we try this conversion the other way around. Parsing a URL string with ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" ","type":"text"},{"text":"also ","type":"text"},{"inlineContent":[{"type":"text","text":"normalizes"}],"type":"emphasis"},{"text":" it, so it cleans up ambiguous syntax and makes the web-compatible interpretation more obvious","type":"text"},{"text":" ","type":"text"},{"text":"to other software and systems. This means that converting a ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" to a ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":" will almost always succeed,","type":"text"},{"text":" ","type":"text"},{"text":"even in cases where the reverse order of operations would have failed.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let urlString = \"http:\/\/foo@evil.com:80@example.com\/\" ","","let webURL = WebURL(urlString)!","print(webURL.hostname)  \/\/ \"example.com\"","print(webURL)           \/\/ \"http:\/\/foo%40evil.com:80@example.com\/\"","\/\/                                    ^^^","\/\/               Problematic '@' sign has been encoded by WebURL,","\/\/                  making the web-compatible interpretation","\/\/                                more obvious.","","URL(webURL)?.host  \/\/ ✅ \"example.com\""],"type":"codeListing"},{"inlineContent":[{"text":"Successful conversion does ","type":"text"},{"inlineContent":[{"type":"text","text":"not"}],"type":"strong"},{"text":" necessarily mean that the URLs have identical strings or components.","type":"text"},{"text":" ","type":"text"},{"text":"The conversion initializers are based on careful study of both standards, and although they are careful","type":"text"},{"text":" ","type":"text"},{"text":"not to permit different interpretations, they are lenient in certain cases when both standards allow it.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"That means they won’t get in your way rejecting irrelevant differences (many times, even a force-unwrap","type":"text"},{"text":" ","type":"text"},{"text":"would not be unreasonable), but they still catch those edge cases where there are genuine mismatches,","type":"text"},{"text":" ","type":"text"},{"text":"as we’ve seen in the previous few examples.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Here is an example of the kind of differences that are allowed. The standard used by ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" requires","type":"text"},{"text":" ","type":"text"},{"text":"that the URL’s scheme and hostname be normalized to lowercase (","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" has to do it; it has no choice).","type":"text"},{"text":" ","type":"text"},{"text":"Luckily, RFC-2396 (the standard used by ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":") explicitly allows that, so even if those parts","type":"text"},{"text":" ","type":"text"},{"text":"of the URL are upper\/mixed-case (perhaps the user had caps-lock on and didn’t notice), the conversion is allowed.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ Foundation's components:","let nsURL = URL(string: \"HTTP:\/\/EXAMPLE.COM\/\")!","print(nsURL)         \/\/ \"HTTP:\/\/EXAMPLE.COM\/\"","print(nsURL.scheme)  \/\/ \"HTTP\"","print(nsURL.host)    \/\/ \"EXAMPLE.COM\"","","\/\/ WebURL normalizes the URL, but the meaning is preserved:","let convertedURL = WebURL(nsURL)!","print(convertedURL)           \/\/ ✅ \"http:\/\/example.com\/\"","print(convertedURL.scheme)    \/\/ ✅ \"http\"","print(convertedURL.hostname)  \/\/ ✅ \"example.com\""],"type":"codeListing"},{"inlineContent":[{"text":"This safe interoperability, which allows as much as it can but also catches real ambiguities, is only possible","type":"text"},{"text":" ","type":"text"},{"text":"because we are converting URL types rather than simply parsing the string again. In the next section, we’ll discuss","type":"text"},{"text":" ","type":"text"},{"text":"applying this idea throughout your application, so it is always clear how a URL is being interpreted.","type":"text"}],"type":"paragraph"},{"text":"One Parser Per String","anchor":"One-Parser-Per-String","level":2,"type":"heading"},{"inlineContent":[{"text":"Consider the following program, demonstrating a simple proxy server. Here’s how it works:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"0️⃣ (Not shown) A client connects to us, says “make a request to this URL for me, please”."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"1️⃣ The server checks the provided URL.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"2️⃣ If the hostname is allowed, the server makes the request, including some private token\/key in the header.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"3️⃣ (Not shown) The response is forwarded to the client.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"text":"The part we’re interested in is split in to two functions - one gets a URL string and checks that it points","type":"text"},{"text":" ","type":"text"},{"text":"to an approved server, and the other makes the authenticated HTTP request:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"Application:"}],"type":"strong"}],"type":"paragraph"},{"syntax":"swift","code":["func checkHostAndMakeRequest(_ urlString: String) throws -> URLSessionDataTask {","  \/\/ 1. Verify host.","  guard checkHostIsAllowed(urlString) else { ","    throw MyAppError.hostIsNotAllowed","  }","  \/\/ 2. Make request.","  return try makeAuthenticatedRequest(urlString, completionHandler: ...)","}"],"type":"codeListing"},{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Allow-List Checker:"}]}],"type":"paragraph"},{"syntax":"swift","code":["let allowedHosts: Set<String> = [ \"example.com\", \/* ... *\/ ]","","func checkHostIsAllowed(_ urlString: \/* ⚠️ *\/ String) -> Bool {","  if let hostname = WebURL(urlString)?.hostname {","    return allowedHosts.contains(hostname)","  }","  return false","}"],"type":"codeListing"},{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Request Engine:","type":"text"}]}],"type":"paragraph"},{"syntax":"swift","code":["func makeAuthenticatedRequest(_ urlString: \/* ⚠️ *\/ String, completionHandler: <...>) throws -> URLSessionDataTask {","  guard let url = Foundation.URL(string: urlString) else {","    throw MyLibraryError.invalidURL","  }","  var request = URLRequest(url: url)","  request.allHTTPHeaderFields = [\"Authorization\" : \"Bearer <...>\"]","  return URLSession.shared.dataTask(with: request, completionHandler: completionHandler)","}"],"type":"codeListing"},{"inlineContent":[{"text":"Each of these functions is reasonable by itself, but the effect of combining them is that a single URL string","type":"text"},{"text":" ","type":"text"},{"text":"is parsed ","type":"text"},{"inlineContent":[{"type":"text","text":"twice"}],"type":"strong"},{"text":", each time by a different parser, and the results may not be consistent. In other words,","type":"text"},{"text":" ","type":"text"},{"text":"the hostname verified by ","type":"text"},{"code":"checkHostIsAllowed","type":"codeVoice"},{"text":" might ","type":"text"},{"inlineContent":[{"type":"text","text":"not"}],"type":"emphasis"},{"text":" be the host that ","type":"text"},{"code":"makeAuthenticatedRequest","type":"codeVoice"},{"text":" actually","type":"text"},{"text":" ","type":"text"},{"text":"makes a request to! 😱","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ The call:","let task = try checkHostAndMakeRequest(\"http:\/\/foo@evil.com:80@example.com\/\")","","\/\/ What happens:","func checkHostAndMakeRequest(_ urlString: String) throws -> URLSessionDataTask {","","  \/\/ ⚠️ 'checkHostIsAllowed' parses the string using WebURL,","  \/\/     so it thinks the host is 'example.com'.","  guard checkHostIsAllowed(urlString) else { ","    throw MyAppError.hostIsNotAllowed","  }","  \/\/ ⚠️ But the request function parses the string using Foundation.URL,","  \/\/    so it actually makes the request to 'evil.com' and leaks our token!","  return try makeAuthenticatedRequest(urlString, completionHandler: ...)","}"],"type":"codeListing"},{"inlineContent":[{"text":"A maliciously-crafted string could exploit this difference to leak authentication tokens to the attacker’s own server;","type":"text"},{"text":" ","type":"text"},{"text":"in fact, this demonstrates ","type":"text"},{"identifier":"https:\/\/bugs.xdavidhu.me\/google\/2021\/12\/31\/fixing-the-unfixable-story-of-a-google-cloud-ssrf\/","isActive":true,"type":"reference"},{"text":" that was used to gain unauthorized access to internal","type":"text"},{"text":" ","type":"text"},{"text":"Google Cloud Platform accounts. Differences between modern and historic URL standards can cause security vulnerabilities,","type":"text"},{"text":" ","type":"text"},{"text":"even outside the Swift ecosystem. It’s not just a Foundation.URL or WebURL thing - it’s something ","type":"text"},{"inlineContent":[{"text":"all developers","type":"text"}],"type":"strong"},{"text":" ","type":"text"},{"text":"need to be aware of. URL libraries often do not align to the same standard, and any data derived from one parser","type":"text"},{"text":" ","type":"text"},{"text":"might be inconsistent with another parser.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Spotting these interactions can be difficult - for instance, the functions may live in separate libraries","type":"text"},{"text":" ","type":"text"},{"text":"and you may not have access to their source code, or the URL string might be in a JSON document or XPC message.","type":"text"},{"text":" ","type":"text"},{"text":"The common feature is that URLs are communicated ","type":"text"},{"type":"strong","inlineContent":[{"text":"without using a URL type","type":"text"}]},{"text":", so we can’t ensure that everybody","type":"text"},{"text":" ","type":"text"},{"text":"who sees the string interprets it the same way.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"We can fix the issue in this case by hoisting URL parsing out of ","type":"text"},{"code":"checkHostIsAllowed","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"makeAuthenticatedRequest","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"and moving it in to the caller. Now, instead of passing strings around and letting each function choose its own","type":"text"},{"text":" ","type":"text"},{"text":"parser, the caller parses the string, and passes around strongly-typed URL values (in this case ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":").","type":"text"},{"text":" ","type":"text"},{"text":"Thanks to checked conversions, the receivers can safely convert to another URL type if they wish - in this case,","type":"text"},{"text":" ","type":"text"},{"code":"makeAuthenticatedRequest","type":"codeVoice"},{"text":" converts to a ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":" and makes the request using ","type":"text"},{"code":"URLSession","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Fixed Allow-List Checker and Request Engine:","type":"text"}]}],"type":"paragraph"},{"syntax":"swift","code":["func checkHostIsAllowed(_ url: \/* ✅ *\/ WebURL) -> Bool {","  if let hostname = url.hostname {","    return allowedHosts.contains(hostname)","  }","  return false","}","","func makeAuthenticatedRequest(_ url: \/* ✅ *\/ WebURL, completionHandler: <...>) throws -> URLSessionDataTask {","  \/\/ ✅ checked WebURL -> Foundation.URL conversion.","  guard let convertedURL = Foundation.URL(url) else {","    throw MyLibraryError.invalidURL","  }","  var request = URLRequest(url: convertedURL)","  request.allHTTPHeaderFields = [\"Authorization\" : \"Bearer <...>\"]","  return URLSession.shared.dataTask(with: request, completionHandler: completionHandler)","}"],"type":"codeListing"},{"content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"We’re showing the explicit "},{"code":"WebURL -> Foundation.URL","type":"codeVoice"},{"type":"text","text":" conversions for clarity, but WebURL also"},{"type":"text","text":" "},{"type":"text","text":"includes convenience APIs so you can create "},{"code":"URLRequest","type":"codeVoice"},{"type":"text","text":"s directly."}],"type":"paragraph"},{"syntax":"swift","code":["func makeAuthenticatedRequest(_ url: WebURL, completionHandler: <...>) throws -> URLSessionDataTask {","  \/\/ ✅ Create URLRequest directly from a WebURL","  var request = URLRequest(url: url)","  request.allHTTPHeaderFields = [\"Authorization\" : \"Bearer <...>\"]","  return URLSession.shared.dataTask(with: request, completionHandler: completionHandler)","}"],"type":"codeListing"}],"style":"tip","name":"Tip","type":"aside"},{"inlineContent":[{"type":"text","text":"Let’s see what happens now that we’ve switched to using URL types rather than strings:"}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ The call:","let task = try checkHostAndMakeRequest(\"http:\/\/foo@evil.com:80@example.com\/\")","","\/\/ What happens:","func checkHostAndMakeRequest(_ urlString: String) throws -> URLSessionDataTask {","","  \/\/ ✅ The string is only parsed once.","  guard let url = WebURL(urlString) else {","    throw MyAppError.invalidURL","  }","  \/\/ ✅ 'checkHostIsAllowed' reads the host as 'example.com'.","  guard checkHostIsAllowed(url) else { ","    throw MyAppError.hostIsNotAllowed","  }","  \/\/ ✅ Typed conversion ensures the request is really made to 'example.com' ","  return try makeAuthenticatedRequest(url, completionHandler: ...)","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"We could even hoist URL parsing again, and make "},{"type":"codeVoice","code":"checkHostAndMakeRequest"},{"type":"text","text":" itself accept a URL value"},{"type":"text","text":" "},{"type":"text","text":"instead of a string. By applying this process repeatedly, we reduce the number of raw URL strings"},{"type":"text","text":" "},{"type":"text","text":"floating around the application, and can leverage the type system to ensure we always interpret values"},{"type":"text","text":" "},{"type":"text","text":"correctly."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"As we’ve seen, there can be subtle, security-sensitive interactions between URL parsers, but by applying"},{"type":"text","text":" "},{"type":"text","text":"some reasonable best-practices, we can get what we want: web-compatible URL parsing and operations"},{"type":"text","text":" "},{"type":"text","text":"(notice the request is made to "},{"type":"codeVoice","code":"\"example.com\""},{"type":"text","text":", not "},{"type":"codeVoice","code":"\"evil.com\""},{"type":"text","text":"), with robustly Foundation interop."},{"type":"text","text":" "},{"type":"text","text":"The guiding rule is that each "},{"type":"emphasis","inlineContent":[{"text":"string","type":"text"}]},{"type":"text","text":" should be parsed by only one parser."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For this reason, we "},{"type":"strong","inlineContent":[{"text":"strongly recommend","type":"text"}]},{"type":"text","text":" that you use typed URL values and the conversion initializers"},{"type":"text","text":" "},{"type":"text","text":"provided by "},{"type":"codeVoice","code":"WebURLFoundationExtras"},{"type":"text","text":". For more complex situations, such as URLs in JSON documents or XPC messages,"},{"type":"text","text":" "},{"type":"text","text":"document which parser should be used, and parse those values early or hide them behind typed APIs,"},{"type":"text","text":" "},{"type":"text","text":"so they do not spread as plain strings."}],"type":"paragraph"},{"text":"Prefer Parsing Using WebURL","anchor":"Prefer-Parsing-Using-WebURL","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"We’ve discussed how you can use the type system to ensure safe conversions, but what about the initial step?"},{"type":"text","text":" "},{"type":"text","text":"Which URL parser should you use to turn your strings in to objects?"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Firstly, if the developer has specified which parser to use for a URL string, "},{"type":"strong","inlineContent":[{"text":"use that parser","type":"text"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Otherwise, matching a web browser is generally a good choice, and probably a more reasonable choice"},{"type":"text","text":" "},{"type":"text","text":"than the standard used by "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":", which has been officially obsolete for several decades."}],"type":"paragraph"},{"content":[{"inlineContent":[{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"I know, this could all sound a bit scary; it’s complexity you didn’t ask for and would much rather do without."},{"type":"text","text":" "},{"type":"text","text":"I get it. But I hope this document has helped to illustrate that the status quo has serious problems,"},{"type":"text","text":" "},{"type":"text","text":"and the complexity, annoying as it is, can be managed very well with some simple best-practices."}],"type":"paragraph"}],"style":"tip","name":"Tip","type":"aside"},{"inlineContent":[{"type":"text","text":"Using "},{"code":"WebURL","type":"codeVoice"},{"type":"text","text":" for parsing and URL manipulation comes with a lot of additional benefits:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"🌍 It’s web-compatible.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Actors on the web platform should use a web-compatible parser to interpret URLs.","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"Foundation.URL"},{"text":" is not web-compatible. It’s as simple as that.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"WebURL behaves just like a browser does, just like JavaScript’s "},{"code":"URL","type":"codeVoice"},{"type":"text","text":" class does, and like many other libraries do."},{"type":"text","text":" "},{"type":"text","text":"In fact, the "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL\/WebURL\/jsModel-swift.property"},{"type":"text","text":" property exposes the exact JS URL API for mixed Swift\/JS"},{"type":"text","text":" "},{"type":"text","text":"code-bases - tested to browser standards, using the same shared test suite that the major browsers use."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"🔩 It’s always normalized."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Parsing a string using "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" cleans up a lot of ambiguous or ill-formatted URLs automatically."},{"type":"text","text":" "},{"type":"text","text":"That means "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" is easier to work with, and produces URL strings which are more interoperable"},{"type":"text","text":" "},{"type":"text","text":"with other libraries and systems."}]},{"type":"paragraph","inlineContent":[{"text":"For example, when ","type":"text"},{"code":"async-http-client","type":"codeVoice"},{"text":" needs to examine a scheme from a ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":"","type":"text"},{"text":" ","type":"text"},{"text":"(like ","type":"text"},{"code":"\"http\"","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"\"https+unix\"","type":"codeVoice"},{"text":"), it has to remember to manually normalize it to lowercase it first -","type":"text"},{"text":" ","type":"text"},{"text":"like it does ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/swift-server\/async-http-client\/blob\/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337\/Sources\/AsyncHTTPClient\/DeconstructedURL.swift#L45","type":"reference"},{"text":" and again way over ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/swift-server\/async-http-client\/blob\/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337\/Sources\/AsyncHTTPClient\/Scheme.swift#L42","type":"reference"},{"text":", in another file.","type":"text"},{"text":" ","type":"text"},{"text":"SwiftPM does the same thing ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-package-manager\/blob\/e25a590dc455baa430f2ec97eacc30257c172be2\/Sources\/PackageCollections\/PackageCollections%2BValidation.swift#L35","type":"reference"},{"text":" and ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-package-manager\/blob\/e25a590dc455baa430f2ec97eacc30257c172be2\/Sources\/PackageCollections\/Model\/Collection.swift#L116","type":"reference"},{"text":" and other places.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"With WebURL, ","type":"text"},{"type":"strong","inlineContent":[{"text":"none of that is necessary","type":"text"}]},{"text":" - that boilerplate can just go. Schemes, hostnames, paths, etc","type":"text"},{"text":" ","type":"text"},{"text":"are all normalized, all the time. Even if you modify the URL and set components - it is always normalized.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Your code becomes more predictable. For example, I noticed that some parts of DocC ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-docc\/blob\/d94139a5e64e9ecf158214b1cded2a2880fc1b02\/Sources\/SwiftDocC\/Model\/TaskGroup.swift#L43-L44","type":"reference"},{"text":" ","type":"text"},{"text":"manually normalize schemes to lowercase - is it intentional or not? Who knows! Like most people,","type":"text"},{"text":" ","type":"text"},{"text":"they’re probably unaware that URL schemes are case-insensitive. With WebURL, they wouldn’t need to worry about it;","type":"text"},{"text":" ","type":"text"},{"text":"their code could remain straightforward but still be correct and consistent.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"😌 Rich, expressive APIs."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"WebURL"},{"text":"‘s ","type":"text"},{"type":"codeVoice","code":".pathComponents"},{"text":" and ","type":"text"},{"type":"codeVoice","code":".formParams"},{"text":" properties give you efficient access to the URL’s path and query.","type":"text"},{"text":" ","type":"text"},{"text":"The ","type":"text"},{"type":"codeVoice","code":".pathComponents"},{"text":" view conforms to ","type":"text"},{"type":"codeVoice","code":"BidirectionalCollection"},{"text":", so you have immediate access to a huge number of","type":"text"},{"text":" ","type":"text"},{"text":"features and algorithms - such as ","type":"text"},{"type":"codeVoice","code":"map"},{"text":", ","type":"text"},{"type":"codeVoice","code":"filter"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"reduce"},{"text":", not to mention slicing, such as ","type":"text"},{"type":"codeVoice","code":"dropLast()"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"And you can even modify through this view, using indexes to perform complex operations super-efficiently.","type":"text"}]},{"code":["let url = WebURL(\"https:\/\/github.com\/karwa\/swift-url\/issues\/63\")!","if url.pathComponents.dropLast().last == \"issues\",","  let issueNumber = url.pathComponents.last.flatMap(Int.init) {"," \/\/ ✅ issueNumber = 63","}"],"type":"codeListing","syntax":"swift"},{"code":["var url = WebURL(\"https:\/\/info.myapp.com\")!","url.pathComponents += [\"music\", \"bands\" \"AC\/DC\"]","\/\/ ✅ \"https:\/\/info.myapp.com\/music\/bands\/AC%2FDC\""],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":".formParams","type":"codeVoice"},{"text":" view takes query parameters to the next level, with dynamic member lookup.","type":"text"},{"text":" ","type":"text"},{"text":"You just get and set values as if they were properties. Zero fuss:","type":"text"}]},{"code":["var url = WebURL(\"https:\/\/example.com\/search?category=food&client=mobile\")!","url.formParams.category  \/\/ \"food\"","url.formParams.client    \/\/ \"mobile\"","","url.formParams.format = \"json\"","\/\/ ✅ \"https:\/\/example.com\/search?category=food&client=mobile&format=json\"","\/\/                                                            ^^^^^^^^^^^"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Here’s a challenge: with WebURL, that was 3 lines of super obvious code.","type":"text"},{"text":" ","type":"text"},{"text":"Now try doing that with ","type":"text"},{"type":"codeVoice","code":"Foundation.URL"},{"text":". Yeah.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":".host"},{"text":" API is less frequently used, but even here we can offer a breakthrough in expressive, robust code.","type":"text"},{"text":" ","type":"text"},{"text":"With WebURL, the URL type tells applications ","type":"text"},{"inlineContent":[{"type":"text","text":"directly"}],"type":"emphasis"},{"text":" which computer the URL points to. I really love this.","type":"text"},{"text":" ","type":"text"},{"text":"I think this is ","type":"text"},{"inlineContent":[{"text":"exactly","type":"text"}],"type":"emphasis"},{"text":" what a Swift URL API should be; it takes a complex, nebulous string","type":"text"},{"text":" ","type":"text"},{"text":"and gives you simple, precise, structured values with strong guarantees.","type":"text"}]},{"code":["let url = WebURL(\"http:\/\/127.0.0.1:8888\/my_site\")!","","guard url.scheme == \"http\" || url.scheme == \"https\" else {","  throw UnknownSchemeError()","}","switch url.host {","  case .domain(let name): ... \/\/ DNS lookup.","  case .ipv4Address(let address): ... \/\/ Connect to known address.","  case .ipv6Address(let address): ... \/\/ Connect to known address.","  case .opaque, .empty, .none: fatalError(\"Not possible for http\")","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Come for the web-compatible URL parsing, or backwards-deployable IDN support;"},{"type":"text","text":" "},{"type":"text","text":"stay because literally everything else is lightyears ahead as well."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And you can still hand values over to legacy "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" code whenever you need to."},{"type":"text","text":" "},{"type":"text","text":"So you can take advantage of these APIs today, where you need them, without forcing everything to be rewritten."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"📊 It’s "},{"type":"emphasis","inlineContent":[{"text":"really","type":"text"}]},{"type":"text","text":" well tested."}],"type":"paragraph"},{"inlineContent":[{"code":"WebURL","type":"codeVoice"},{"text":" is extensively tested by the Web Platform Tests. The WPT is a shared test database","type":"text"},{"text":" ","type":"text"},{"text":"used by the major browsers and other libraries; we pool our implementation experience to ensure that","type":"text"},{"text":" ","type":"text"},{"text":"any ambiguities or divergence is spotted and eliminated (sometimes the standard is ambiguous; that gets corrected).","type":"text"},{"text":" ","type":"text"},{"text":"The WebURL project has made a lot of contributions towards that effort, including finding and fixing issues","type":"text"},{"text":" ","type":"text"},{"text":"in browsers and elsewhere.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This whole process is a really valuable positive cycle, and helps give you confidence that WebURL will work"},{"type":"text","text":" "},{"type":"text","text":"just like, say, Safari. We literally use the same test suite."}],"type":"paragraph"},{"inlineContent":[{"text":"Unfortunately, ","type":"text"},{"type":"codeVoice","code":"Foundation.URL"},{"text":" simply cannot participate in that process, or anything like it.","type":"text"},{"text":" ","type":"text"},{"text":"Nobody’s writing new implementations of the obsolete RFC-2396.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The WPT alone is over 3x as large as Foundation’s test database, and includes much better quality test-cases"},{"type":"text","text":" "},{"type":"text","text":"because it is exposed to the entire web and actively maintained. Foundation’s tests actually include"},{"type":"text","text":" "},{"type":"text","text":"plenty of mistakes (!), so it actually tests incorrect behavior 🤦‍♂️. My guess is that Foundation is not able"},{"type":"text","text":" "},{"type":"text","text":"to fix those due to compatibility, but who knows? They don’t respond at all to any of the dozen or so bug reports"},{"type":"text","text":" "},{"type":"text","text":"I’ve filed, showing some pretty shocking bugs in "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":". That’s not even to mention that lots of"},{"type":"text","text":" "},{"type":"text","text":"publicly-known URL exploits are actually monkey-patched in WebKit rather than being fixed at the source"},{"type":"text","text":" "},{"type":"text","text":"(which is the buggy CFURL parser). Perhaps they can’t fix those, either? I don’t like to mention that kind of thing"},{"type":"text","text":" "},{"type":"text","text":"due to responsible disclosure, but you deserve to know that your code might be vulnerable. The disclosure process"},{"type":"text","text":" "},{"type":"text","text":"happened years ago."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"In contrast, testing has been a major focus of "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" since the beginning. As well as the WPT,"},{"type":"text","text":" "},{"type":"text","text":"WebURL is tested by "},{"type":"emphasis","inlineContent":[{"type":"text","text":"hundreds"}]},{"type":"text","text":" of additional tests, covering every aspect of its API. Our coverage is about 88%"},{"type":"text","text":" "},{"type":"text","text":"as of writing (generally regarded as excellent), and the gaps are mostly things that can’t easily be tested"},{"type":"text","text":" "},{"type":"text","text":"in Swift (such as assertion failures). And if "},{"type":"emphasis","inlineContent":[{"text":"all of that","type":"text"}]},{"type":"text","text":" wasn’t enough, "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" is regularly fuzz-tested,"},{"type":"text","text":" "},{"type":"text","text":"as are the URL type conversions. Because our checked conversions actually "},{"type":"emphasis","inlineContent":[{"type":"text","text":"account for bugs in Foundation"}]},{"type":"text","text":" "},{"type":"text","text":"to make sure nothing slips through the cracks."}],"type":"paragraph"},{"inlineContent":[{"text":"All of this means that you can have confidence adopting ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"right now","type":"text"}]},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"Obviously nobody can guarantee zero bugs ever, but WebURL is a massive improvement - and as a Swift package,","type":"text"},{"text":" ","type":"text"},{"text":"any fixes can be implemented and deployed immediately. No more chucking bug reports in to a void","type":"text"},{"text":" ","type":"text"},{"text":"and being disappointed as year after year they go ignored and unfixed.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"🔥 It’s blazing fast."}],"type":"paragraph"},{"inlineContent":[{"code":"WebURL","type":"codeVoice"},{"type":"text","text":" is regularly benchmarked, and comes out faster than "},{"code":"Foundation.URL","type":"codeVoice"},{"type":"text","text":" for "},{"inlineContent":[{"type":"text","text":"every"}],"type":"emphasis"},{"type":"text","text":" operation;"},{"type":"text","text":" "},{"type":"text","text":"whether you’re parsing URL strings, modifying components, iterating through the path, etc."},{"type":"text","text":" "},{"type":"text","text":"In particular, it is "},{"inlineContent":[{"type":"text","text":"orders of magnitude"}],"type":"strong"},{"type":"text","text":" faster on low-end\/IoT platforms like the Raspberry Pi,"},{"type":"text","text":" "},{"type":"text","text":"enabling applications which were previously so slow they’d be impractical."}],"type":"paragraph"}]}],"type":"orderedList"},{"text":"A Note on Round-Tripping","anchor":"A-Note-on-Round-Tripping","level":2,"type":"heading"},{"inlineContent":[{"text":"Round-tripping refers to taking a value (say, a ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":"), converting it to another type (","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":"),","type":"text"},{"text":" ","type":"text"},{"text":"and then converting back to the original type (to ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" again). Some libraries and data structures need","type":"text"},{"text":" ","type":"text"},{"text":"strong guarantees about that situation, so here it is:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" which can be converted to a "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" value can "},{"type":"strong","inlineContent":[{"text":"always","type":"text"}]},{"type":"text","text":" be converted back to a "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" which can be converted to a "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" can "},{"type":"strong","inlineContent":[{"type":"text","text":"almost always"}]},{"type":"text","text":" be converted back to a "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":"."}]},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"There is one, very rare situation where a Foundation -> WebURL conversion cannot be converted back:","type":"text"},{"text":" ","type":"text"},{"text":"HTTP URLs whose hostnames contain percent-encoded special characters. These will get decoded by ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"but can’t be re-encoded for the conversion back to Foundation.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["(Foundation \"http:\/\/te%7Bs%7Dt\/\") -> (WebURL \"http:\/\/te{s}t\/\") -> (Rejected by Foundation)","                      ^^^ ^^^                          ^ ^"]},{"type":"paragraph","inlineContent":[{"text":"These are not valid DNS domain names, so this is mostly a theoretical concern.","type":"text"},{"text":" ","type":"text"},{"text":"Generally, you can assume that Foundation -> WebURL conversion means the result can be converted back","type":"text"},{"text":" ","type":"text"},{"text":"to a ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":".","type":"text"}]}],"name":"Note","style":"note"}]}],"type":"unorderedList"},{"inlineContent":[{"text":"Sometimes, when converting a ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" to Foundation, we need to add percent-encoding; this means the round-trip","type":"text"},{"text":" ","type":"text"},{"text":"result will not be equal to the original ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" value. However, you can use the ","type":"text"},{"code":"WebURL.encodedForFoundation","type":"codeVoice"},{"text":" ","type":"text"},{"text":"property to add that percent-encoding in advance; if this pre-encoded URL can be converted to a ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"it is guaranteed to round-trip to exactly the same ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" value.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["func processURL(_ webURL: WebURL) throws {","","  let encodedWebURL = webURL.encodedForFoundation","  \/\/ ℹ️                     ^^^^^^^^^^^^^^^^^^^^^","  \/\/ Percent-encoding is added by default when converting to Foundation.","  \/\/ If we do it now, we know the round-trip result will equal 'encodedWebURL'.","","  guard let convertedURL = URL(encodedWebURL) else { throw InvalidURLError() }","","  \/\/ Do whatever you needed to do with Foundation... ","  let dataTask = URLSession.shared.dataTask(from: convertedURL)","  let urlFromDataTask = dataTask.originalRequest!.url!","","  \/\/ ✅ A converted WebURL can always convert back. ","  let roundtripWebURL = WebURL(urlFromDataTask)!","","  \/\/ ✅ The round-trip result is equal to 'encodedWebURL'. ","  assert(encodedWebURL == roundtripWebURL)","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"It is not generally possible to know in advance what the result of a "},{"code":"{Foundation -> WebURL -> Foundation}","type":"codeVoice"},{"type":"text","text":" round-trip"},{"type":"text","text":" "},{"type":"text","text":"will be. There is no equivalent of "},{"code":"WebURL.encodedForFoundation","type":"codeVoice"},{"type":"text","text":" which normalizes a "},{"code":"Foundation.URL","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}],"kind":"content"}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL\/FoundationInterop"},"metadata":{"modules":[{"name":"WebURL"}],"title":"Using WebURL with Foundation","roleHeading":"Article","role":"article"},"sections":[],"references":{"https://github.com/apple/swift-docc/blob/d94139a5e64e9ecf158214b1cded2a2880fc1b02/Sources/SwiftDocC/Model/TaskGroup.swift#L43-L44":{"identifier":"https:\/\/github.com\/apple\/swift-docc\/blob\/d94139a5e64e9ecf158214b1cded2a2880fc1b02\/Sources\/SwiftDocC\/Model\/TaskGroup.swift#L43-L44","title":"don’t","type":"link","url":"https:\/\/github.com\/apple\/swift-docc\/blob\/d94139a5e64e9ecf158214b1cded2a2880fc1b02\/Sources\/SwiftDocC\/Model\/TaskGroup.swift#L43-L44","titleInlineContent":[{"type":"text","text":"don’t"}]},"https://github.com/apple/swift-package-manager/blob/e25a590dc455baa430f2ec97eacc30257c172be2/Sources/PackageCollections/PackageCollections%2BValidation.swift#L35":{"identifier":"https:\/\/github.com\/apple\/swift-package-manager\/blob\/e25a590dc455baa430f2ec97eacc30257c172be2\/Sources\/PackageCollections\/PackageCollections%2BValidation.swift#L35","title":"here","type":"link","titleInlineContent":[{"type":"text","text":"here"}],"url":"https:\/\/github.com\/apple\/swift-package-manager\/blob\/e25a590dc455baa430f2ec97eacc30257c172be2\/Sources\/PackageCollections\/PackageCollections%2BValidation.swift#L35"},"doc://com.karwa.WebURL/documentation/WebURL/WebURL/jsModel-swift.property":{"identifier":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL\/WebURL\/jsModel-swift.property","title":"jsModel","role":"symbol","kind":"symbol","abstract":[{"text":"A read-write view of this URL with the same API as JavaScript’s ","type":"text"},{"type":"codeVoice","code":"URL"},{"text":" class.","type":"text"}],"fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"jsModel","kind":"identifier"},{"text":": ","kind":"text"},{"text":"WebURL","kind":"typeIdentifier","preciseIdentifier":"s:6WebURLAAV"},{"text":".","kind":"text"},{"text":"JSModel","kind":"typeIdentifier","preciseIdentifier":"s:6WebURLAAV7JSModelV"}],"url":"\/documentation\/weburl\/weburl\/jsmodel-swift.property","type":"topic"},"https://bugs.xdavidhu.me/google/2021/12/31/fixing-the-unfixable-story-of-a-google-cloud-ssrf/":{"identifier":"https:\/\/bugs.xdavidhu.me\/google\/2021\/12\/31\/fixing-the-unfixable-story-of-a-google-cloud-ssrf\/","title":"a real vulnerability","type":"link","url":"https:\/\/bugs.xdavidhu.me\/google\/2021\/12\/31\/fixing-the-unfixable-story-of-a-google-cloud-ssrf\/","titleInlineContent":[{"type":"text","text":"a real vulnerability"}]},"https://github.com/swift-server/async-http-client/blob/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337/Sources/AsyncHTTPClient/DeconstructedURL.swift#L45":{"identifier":"https:\/\/github.com\/swift-server\/async-http-client\/blob\/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337\/Sources\/AsyncHTTPClient\/DeconstructedURL.swift#L45","title":"here","type":"link","titleInlineContent":[{"type":"text","text":"here"}],"url":"https:\/\/github.com\/swift-server\/async-http-client\/blob\/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337\/Sources\/AsyncHTTPClient\/DeconstructedURL.swift#L45"},"doc://com.karwa.WebURL/documentation/WebURL":{"role":"collection","title":"WebURL","url":"\/documentation\/weburl","type":"topic","identifier":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL","abstract":[{"type":"text","text":"A new URL type for Swift."}],"kind":"symbol"},"https://github.com/apple/swift-package-manager/blob/e25a590dc455baa430f2ec97eacc30257c172be2/Sources/PackageCollections/Model/Collection.swift#L116":{"identifier":"https:\/\/github.com\/apple\/swift-package-manager\/blob\/e25a590dc455baa430f2ec97eacc30257c172be2\/Sources\/PackageCollections\/Model\/Collection.swift#L116","title":"here","type":"link","url":"https:\/\/github.com\/apple\/swift-package-manager\/blob\/e25a590dc455baa430f2ec97eacc30257c172be2\/Sources\/PackageCollections\/Model\/Collection.swift#L116","titleInlineContent":[{"type":"text","text":"here"}]},"https://github.com/swift-server/async-http-client/blob/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337/Sources/AsyncHTTPClient/Scheme.swift#L42":{"identifier":"https:\/\/github.com\/swift-server\/async-http-client\/blob\/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337\/Sources\/AsyncHTTPClient\/Scheme.swift#L42","title":"here","type":"link","titleInlineContent":[{"type":"text","text":"here"}],"url":"https:\/\/github.com\/swift-server\/async-http-client\/blob\/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337\/Sources\/AsyncHTTPClient\/Scheme.swift#L42"}}}